<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="" >

<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap"
    rel="stylesheet">
          <title>Day02</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { font-weight: bold; } /* Alert */
    code span.an { font-style: italic; } /* Annotation */
    code span.cf { font-weight: bold; } /* ControlFlow */
    code span.co { font-style: italic; } /* Comment */
    code span.cv { font-style: italic; } /* CommentVar */
    code span.do { font-style: italic; } /* Documentation */
    code span.er { font-weight: bold; } /* Error */
    code span.in { font-style: italic; } /* Information */
    code span.kw { font-weight: bold; } /* Keyword */
    code span.pp { font-weight: bold; } /* Preprocessor */
    code span.wa { font-style: italic; } /* Warning */
  </style>
    <link rel="stylesheet" href="style.css" />
        <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=Libre+Baskerville:ital,wght@0,400..700;1,400..700&display=swap"
    rel="stylesheet">
</head>

<body>
    <header id="title-block-header">
    <div>
      <div class='header-title'>Advent of Code 2025</div>
      <div class='header-subtitle'>in Haskell</div>
      <div class='header-meta'>
        <div class='header-author'>by Hugo Vilela</div>
        <div class='header-date'>December 2025</div>
      </div>
    </div>
  </header>
    <nav id="TOC" role="doc-toc" class="row">
    <h2>Table of Contents:</h2>
    <ul>
    <li><a href="#day-1" id="toc-day-1">Day 1</a>
    <ul>
    <li><a href="#part-1" id="toc-part-1">Part 1</a></li>
    <li><a href="#part-2" id="toc-part-2">Part 2</a></li>
    </ul></li>
    </ul>
  </nav>
  
  <div class="row">
  <div class="lhs">
  <p># Day 2 ## Part 1</p>
  <p>Today’s problem was easier than expected, for part 1 we get a list
  of ranges. ie.</p>
  <div class="sourceCode" id="cb1"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(90 - 10000)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>(57 - 82345)</span></code></pre></div>
  <p>We need to find all invalidIds between each range and sum them. An
  id is invalid if it’s first and second half are equal (ie. 1010,
  123123, 88).</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb2"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day02</span> <span class="kw">where</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;))</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.Split</span> (chunksOf)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>As always, we start with parsing the input, a list of
  <code>(Int, Int)</code> seems fitting</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb3"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Range</span> <span class="ot">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Range</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> T.pack <span class="op">&gt;&gt;&gt;</span> T.splitOn <span class="st">&quot;,&quot;</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> parseRange</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    parseRange str <span class="ot">=</span> <span class="kw">let</span> [a, b] <span class="ot">=</span> T.splitOn <span class="st">&quot;-&quot;</span> str</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">in</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> <span class="op">$</span> T.unpack a, <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> <span class="op">$</span> T.unpack b)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Put simply, for each range we get the invalid ids and sum them</p>
  <p><code>invalidIdsInRange</code> - checks all numbers in a range,
  filters only the invalid ones and sums them</p>
  <p><code>isInvalid</code> - returns True if the number has even length
  and its first and second half are equal</p>
  <p>There really isn’t much to see here</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb4"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> parse <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> invalidIdsInRange <span class="op">&gt;&gt;&gt;</span> <span class="fu">sum</span> </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    invalidIdsInRange ::</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    invalidIdsInRange (a, b) <span class="ot">=</span> <span class="fu">sum</span> <span class="op">$</span> <span class="fu">filter</span> isInvalid <span class="op">$</span> [a<span class="op">..</span>b]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    isInvalid ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    isInvalid n <span class="ot">=</span> <span class="kw">let</span> str <span class="ot">=</span> <span class="fu">show</span> n</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>                      [<span class="fu">fst</span>, <span class="fu">snd</span>] <span class="ot">=</span> chunksOf (<span class="fu">length</span> str <span class="ot">`div`</span> <span class="dv">2</span>) str</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">in</span> <span class="fu">even</span> (<span class="fu">length</span> str) <span class="op">&amp;&amp;</span> <span class="fu">fst</span> <span class="op">==</span> <span class="fu">snd</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>## Part 2 Part 2 bumps the difficulty slightly now an id is invalid
  if it consists of a number repeated 2 or more times, ie.</p>
  <ul>
  <li>111 (1 repeated 3 times)</li>
  <li>123123123 (123 repeated 3 times)</li>
  <li>88 (8 repeated 2 times)</li>
  </ul>
  <p><strong>Takeaway</strong>: we can check for divisors of the length
  of the string, break the string into that many chunks and check if all
  chunks are equal</p>
  <p>The only change here is in <code>isInvalid</code> where we get the
  divisors of length of number, and check if any of the divisors holds
  the property above</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb5"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> parse <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> invalidIdsInRange <span class="op">&gt;&gt;&gt;</span> <span class="fu">sum</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  invalidIdsInRange ::</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  invalidIdsInRange (a, b) <span class="ot">=</span> <span class="fu">sum</span> <span class="op">$</span> <span class="fu">filter</span> isInvalid <span class="op">$</span> [a<span class="op">..</span>b]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  isInvalid ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>  isInvalid n <span class="ot">=</span> <span class="kw">let</span> str <span class="ot">=</span> <span class="fu">show</span> <span class="op">$</span> n</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                    divs <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span><span class="fu">length</span> str <span class="ot">`div`</span> <span class="dv">2</span>] <span class="op">&amp;</span> <span class="fu">filter</span> (\it <span class="ot">-&gt;</span> <span class="fu">length</span> str <span class="ot">`mod`</span> it <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span> <span class="fu">any</span> (allEqual <span class="op">.</span> <span class="fu">flip</span> chunksOf str) divs</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="ot">allEqual ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>allEqual (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">all</span> (<span class="op">==</span> x) xs</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>allEqual [] <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p># Day 3 ## Part 1</p>
  <p>### The problem Our puzzle input this time is a list of Int</p>
  <div class="sourceCode" id="cb6"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>987654321111111</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>811111111111119</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>234234234234278</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>818181911112111</span></code></pre></div>
  <p>each row is a bank of batteries our task is to find the maximum
  joltage for each bank and sum all of them</p>
  <p>In part 1 the maximum joltage of the bank is the biggest number
  resulting from picking any 2-digits in the bank (without changing
  their order)</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb7"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TupleSections #-}</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day03</span> <span class="kw">where</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;), on)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span> (<span class="dt">Foldable</span>(foldMap&#39;))</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span> (<span class="dt">Sum</span>(<span class="dt">Sum</span>, getSum))</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sortBy)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Our model today is a <code>[[Int]]</code> we’re concerning
  ourselves with digits today.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb8"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Bank</span> <span class="ot">=</span> [<span class="dt">Int</span>]</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Parsing is straighforward, we split the string into lines and
  convert each char in each line to an Int</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb9"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">lines</span> </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> <span class="op">.</span> (<span class="op">:</span>[])))</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>we calculate the joltage of each bank by generating all possible
  <code>batteryPairs</code> getting their joltage and picking the
  greatest.</p>
  <p>then we just sum and that’s it</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb10"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solve <span class="op">.</span> parse</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    solve ::</span> [<span class="dt">Bank</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    solve <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> getBankJoltage</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    getBankJoltage ::</span> <span class="dt">Bank</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    getBankJoltage <span class="ot">=</span> <span class="fu">maximum</span> <span class="op">.</span> allJoltagesInBank</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    allJoltagesInBank ::</span> <span class="dt">Bank</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    allJoltagesInBank <span class="ot">=</span> <span class="fu">map</span> (\(a, b) <span class="ot">-&gt;</span> a <span class="op">*</span> <span class="dv">10</span> <span class="op">+</span> b) <span class="op">.</span> batteryPairs</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    batteryPairs ::</span> <span class="dt">Bank</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    batteryPairs (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">map</span> (x,) xs <span class="op">&lt;&gt;</span> batteryPairs xs</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    batteryPairs [] <span class="ot">=</span> []</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>## Part 2</p>
  <p>Part 2 is a bit more interesting, this time we need to pick 12
  batteries to find the joltage.</p>
  <p>The key of this algorithm is starting backwards, to make it simple,
  let’s imagine a bank with 6 batteries where we need to pick 4 to find
  the joltage.</p>
  <p>Our first battery can be anywhere but the last 3 places, because in
  the “worst case scenario” that the digits are in ascending order we
  still need 3 batteries after the first.</p>
  <p>The keypoint here is that we can greedily pick the greatest digit
  of those available, because we’re always picking the next most
  significant digit. In case there’s a tie we should pick the first one
  to give more choice to the next digits</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb11"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Most of part 2 is the same as part 1 except we have
  <code>getMaxJoltageOf</code> which takes the number of batteries
  needed to form a joltage and a bank and returns the maximum
  joltage</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb12"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | The solution for part2 is more efficient and could be used for part1 by using (getMaxJoltageOf 2)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solve <span class="op">.</span> parse</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    solve ::</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    solve <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> (getMaxJoltageOf <span class="dv">12</span>)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>For each digit we find the available positions and the return the
  greatest number in the earliest position.</p>
  <p>We achieve this through a fold keeping track of the greatest digit
  so far and its position</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb13"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- |returns the max joltage of taking `size` batteries in a bank</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    getMaxJoltageOf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    getMaxJoltageOf size digits <span class="ot">=</span> mergeDigits <span class="op">$</span> <span class="fu">reverse</span> <span class="op">$</span> go <span class="dv">0</span> <span class="dv">0</span> []</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="ot">        go ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        go n _ acc <span class="op">|</span> n <span class="op">==</span> size <span class="ot">=</span> acc</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- | recursively find the next best digit</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- when picking a digit we know what positions in the original array are valid</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- we pick the greatest digit and if there are multiple we pick the first</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        go ix <span class="fu">minBound</span> acc <span class="ot">=</span> <span class="kw">let</span> digitBounds <span class="ot">=</span> [<span class="fu">minBound</span><span class="op">..</span>(<span class="fu">length</span> digits <span class="op">-</span> size <span class="op">+</span> ix)]</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>                                 (maxDigitIx, maxDigit) <span class="ot">=</span> <span class="fu">head</span> <span class="op">.</span> sortBy (<span class="fu">compare</span> <span class="ot">`on`</span> <span class="fu">negate</span> <span class="op">.</span> <span class="fu">snd</span>) <span class="op">$</span> <span class="fu">map</span> (\(ix, ix2) <span class="ot">-&gt;</span> (ix, digits<span class="op">!!</span>ix2)) <span class="op">$</span> <span class="fu">zip</span> digitBounds digitBounds</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>                              <span class="kw">in</span> go (ix <span class="op">+</span> <span class="dv">1</span>) (maxDigitIx <span class="op">+</span><span class="dv">1</span>) (maxDigit<span class="op">:</span>acc)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>To merge digits into a number we just reverse them a multiply by 10
  to the power of its index.</p>
  <p>The traditional algorithm</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb14"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Merges digits into number. </span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- mergeDigits [1, 2, 3] === 123</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="ot">mergeDigits ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>mergeDigits xs <span class="ot">=</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] (<span class="fu">reverse</span> xs) </span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> foldMap&#39; (\(ix, d) <span class="ot">-&gt;</span> <span class="dt">Sum</span> (d <span class="op">*</span> <span class="dv">10</span> <span class="op">^</span> ix))</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> getSum</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p># Day 8 ## Part 1</p>
  <p>Today we get a list of electrical junctions in 3D space</p>
  <div class="sourceCode" id="cb15"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>162,817,812</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>57,618,57</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>906,360,560</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>...</span></code></pre></div>
  <p>We’re asked to pick the two closest ones and add them to a circuit,
  which may result in either:</p>
  <ul>
  <li>A new circuit with just the two (if none are in a circuit)</li>
  <li>Adding one of them to the other’s circuit (if the other is already
  in a circuit)</li>
  <li>Merging two circuits together.</li>
  </ul>
  <p>We need to do this 1000 times and then multiply the length of the 3
  most populated circuits.</p>
  <p>If the operations above remind you of a DisjointSet then you’re on
  the right track. Indeed I suspect using a DistjoinSet would result in
  a more efficient solution.</p>
  <p>However, today’s challenge is the reason I learned about disjoint
  sets and only after I had already a solution.</p>
  <p>So today we’ll look at my naive solution.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb16"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-name-shadowing #-}</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day08</span> <span class="kw">where</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Linear.V3</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> (on)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.Split</span> (splitOn)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span> (readFile&#39;)</span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sortBy)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashMap.Strict</span> (<span class="dt">HashMap</span>, (!?) )</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.HashMap.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Lens</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State.Lazy</span> (<span class="dt">State</span>, evalState)</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM_)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>As usual we start with a model. We’ll use Ints to identify circuits
  and 3-dimensional vectors for the junctions</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb17"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CircuitId</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Junction</span> <span class="ot">=</span> (<span class="dt">V3</span> <span class="dt">Int</span>)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>We split the input into lines and parse a junction for each
  line</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb18"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Junction</span>]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">map</span> parseJunction <span class="op">.</span> <span class="fu">lines</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseJunction ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Junction</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  parseJunction line <span class="ot">=</span> <span class="kw">let</span> [x, y, z] <span class="ot">=</span> splitOn <span class="st">&quot;,&quot;</span> line</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">in</span> <span class="dt">V3</span> (<span class="fu">read</span> x) (<span class="fu">read</span> y) (<span class="fu">read</span> z)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>A simple euclidean distance function. We can do without
  <code>sqrt</code> because the relative distances remain the same.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb19"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">distanceTo ::</span> <span class="dt">Junction</span> <span class="ot">-&gt;</span> <span class="dt">Junction</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>distanceTo (<span class="dt">V3</span> x1 y1 z1) (<span class="dt">V3</span> x2 y2 z2) <span class="ot">=</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>         (<span class="fu">fromIntegral</span> (x2 <span class="op">-</span> x1)) <span class="op">**</span> <span class="fl">2.0</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>       <span class="op">+</span> (<span class="fu">fromIntegral</span> (y2 <span class="op">-</span> y1)) <span class="op">**</span> <span class="fl">2.0</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>       <span class="op">+</span> (<span class="fu">fromIntegral</span> (z2 <span class="op">-</span> z1)) <span class="op">**</span> <span class="fl">2.0</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>And finally, <code>distances</code> gets us the sorted list of the
  nearest junctions. we just find all pairs of junctions and sort them
  with <code>distanceTo</code></p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb20"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">distances ::</span> [<span class="dt">Junction</span>] <span class="ot">-&gt;</span> [(<span class="dt">Junction</span>, <span class="dt">Junction</span>)]</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>distances vecs <span class="ot">=</span> [ (v1, v2)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>                 <span class="op">|</span> (ix, v1) <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] vecs</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>                 , v2 <span class="ot">&lt;-</span> <span class="fu">drop</span> (ix <span class="op">+</span> <span class="dv">1</span>) vecs</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>                 ] <span class="op">&amp;</span> sortBy (<span class="fu">compare</span> <span class="ot">`on`</span> <span class="fu">uncurry</span> distanceTo)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Let’s expand our model:</p>
  <p><code>ProblemState</code> keeps track of a few things,</p>
  <ul>
  <li><strong><code>nextCircuitId</code></strong> - we’ll need this to
  know what id to use when we create a new circuit</li>
  <li><strong><code>junctions</code></strong> - maps a junction to a
  circuit (allows to ask the circuit of a junction efficiently)</li>
  <li><strong><code>circuits</code></strong> - maps a circuit to a list
  of junction (allows us to get all junctions in a circuit
  efficiently)</li>
  </ul>
  <p>this should be enough to perform the algorithm.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb21"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ProblemState</span> <span class="ot">=</span> <span class="dt">ProblemState</span> {</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  _nextCircuitId ::</span> <span class="dt">CircuitId</span>,</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  _junctions ::</span> <span class="dt">HashMap</span> <span class="dt">Junction</span> <span class="dt">CircuitId</span>,</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  _circuits ::</span> <span class="dt">HashMap</span> <span class="dt">CircuitId</span> [<span class="dt">Junction</span>]</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="ot">emptyState ::</span> <span class="dt">ProblemState</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>emptyState <span class="ot">=</span> <span class="dt">ProblemState</span> <span class="dv">0</span> Map.empty Map.empty</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Today we’re using the State monad + the lens library to help
  keeping our solution readable.</p>
  <p>If you’re not proficient with lenses I highly recommend <a
  href="https://leanpub.com/optics-by-example/">This Book</a>.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb22"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>makeLenses <span class="dt">&#39;ProblemState</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>We’ll be using the State Monad under the name Solver to model our
  computations.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb23"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Solver</span> a <span class="ot">=</span> <span class="dt">State</span> <span class="dt">ProblemState</span> a</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Let’s start with a few utility functions</p>
  <p>To add a junction to a circuit we need to update both the
  <code>junctions</code> and <code>circuits</code> data structures</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb24"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addJunctionToCircuit ::</span> (<span class="dt">V3</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">CircuitId</span> <span class="ot">-&gt;</span> <span class="dt">Solver</span> ()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>addJunctionToCircuit junction circuitId <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    junctions <span class="op">%=</span> Map.insert junction circuitId</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    circuits <span class="op">%=</span> Map.alter (insert junction) circuitId</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> ()</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    insert ::</span> <span class="dt">V3</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">V3</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">V3</span> <span class="dt">Int</span>]</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    insert junction <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Just</span> [junction]</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    insert junction (<span class="dt">Just</span> js) <span class="ot">=</span> <span class="dt">Just</span> (junction <span class="op">:</span> js)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Now we can do one full step of the algorithm, picking two junctions
  and deciding how to for junctions <code>(a, b)</code> there are 5
  possible cases that we need to handle</p>
  <ol type="1">
  <li>junction <code>a</code> is in circuit <code>ca</code> - we insert
  junction <code>b</code> in circuit <code>ca</code></li>
  <li>junction <code>b</code> is in circuit <code>cb</code> - same as
  above with b</li>
  <li>both junctions are in the same circuit - nothing changes</li>
  <li>both junctions are in different circuits - we need to merge the
  circuits</li>
  </ol>
  <ul>
  <li><ol type="1">
  <li>move all junctions in <code>ca</code> to <code>cb</code></li>
  </ol></li>
  <li><ol start="2" type="1">
  <li>delete the <code>ca</code> circuit</li>
  </ol></li>
  </ul>
  <ol start="5" type="1">
  <li>neither <code>a</code> nor <code>b</code> are in a circuit -
  create a new circuit with both</li>
  </ol>
  <ul>
  <li>add both to a circuit with a new id</li>
  <li>increase the <code>nextCircuitId</code> tracker</li>
  </ul>
  <p>Ooof, well, that’s the juice of today’s problems and the biggest
  function today.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb25"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addJunctionPair ::</span> (<span class="dt">V3</span> <span class="dt">Int</span>, <span class="dt">V3</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Solver</span> ()</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>addJunctionPair (a, b) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- find the circuits where a and b belong</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  mCa <span class="ot">&lt;-</span> uses junctions (<span class="op">!?</span> a)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  mCb <span class="ot">&lt;-</span> uses junctions (<span class="op">!?</span> b)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> (mCa, mCb) <span class="kw">of</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Just</span> ca, <span class="dt">Nothing</span>) <span class="ot">-&gt;</span> addJunctionToCircuit b ca</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Nothing</span>, <span class="dt">Just</span> cb) <span class="ot">-&gt;</span> addJunctionToCircuit a cb</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Just</span> ca, <span class="dt">Just</span> cb) <span class="op">|</span> ca <span class="op">==</span> cb <span class="ot">-&gt;</span> <span class="fu">return</span> ()</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Just</span> ca, <span class="dt">Just</span> cb) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>      junctionsInCa <span class="ot">&lt;-</span> uses circuits (<span class="op">Map.!</span> ca)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>      forM_ junctionsInCa <span class="op">$</span> <span class="fu">flip</span> addJunctionToCircuit cb</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>      circuits <span class="op">%=</span> Map.delete ca</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Nothing</span>, <span class="dt">Nothing</span>) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>      nextId <span class="ot">&lt;-</span> use nextCircuitId </span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>      nextCircuitId <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>      addJunctionToCircuit a nextId</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>      addJunctionToCircuit b nextId</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>With all of that out of the way we’re ready to implement part1: 1.
  We take the 1000 smallest pairs of distances 2. Go through each of
  them with <code>forM_</code> to add them 3. calculate the score - this
  long-ass one-liner takes the circuits and finds the 3 longest ones and
  multiplies their lengths</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb26"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> [<span class="dt">V3</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>solvePart1 junctions <span class="ot">=</span> <span class="fu">flip</span> evalState emptyState <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pairs <span class="ot">=</span> <span class="fu">take</span> <span class="dv">1000</span> <span class="op">$</span> distances junctions</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  forM_ pairs addJunctionPair</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>  uses circuits (Map.toList <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">length</span> <span class="op">.</span> <span class="fu">snd</span>) <span class="op">&gt;&gt;&gt;</span> sortBy (<span class="fu">flip</span> <span class="fu">compare</span>) <span class="op">&gt;&gt;&gt;</span> <span class="fu">take</span> <span class="dv">3</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">product</span>)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>## Part 2 For part 2 we’re asked to find the first pair of
  junctions that when added will form 1 final circuit with all
  junctions, and multiply their x coordinates.</p>
  <p>Turns out we already have everything to solve part2 as well.</p>
  <p><code>addUntilDone</code> - adds pairs until the condition is met
  and returns the correct pair</p>
  <p>We multiply their x coordinates and VOILA, day 8 is done.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb27"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> [<span class="dt">V3</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>solvePart2 js <span class="ot">=</span> <span class="fu">flip</span> evalState emptyState <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pairs <span class="ot">=</span> distances js</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>      addUntilDone [] <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;unreachable&quot;</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>      addUntilDone (n<span class="op">:</span>rest) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>        addJunctionPair n</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>        junctionCount <span class="ot">&lt;-</span> uses junctions Map.size</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>        circuitCount <span class="ot">&lt;-</span> uses circuits Map.size</span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> junctionCount <span class="op">==</span> <span class="fu">length</span> js <span class="op">&amp;&amp;</span> circuitCount <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>          <span class="kw">then</span> <span class="fu">return</span> n</span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> addUntilDone rest</span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>  (a, b) <span class="ot">&lt;-</span> addUntilDone pairs</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> a<span class="op">^.</span>_x <span class="op">*</span> b<span class="op">^.</span>_x</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-1">Day 1</h1>
  <h2 id="part-1">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle involves a combination lock with a rotating dial.
  We’re given a series of left (L) and right (R) rotations, and we need
  to count how many times the dial lands exactly on position 0 after
  completing each rotation.</p>
  <p>The dial has 100 positions (0-99) and starts at position 50.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb28"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>First, a few ceremonies…</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb29"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day01</span> <span class="kw">where</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section class="lhs">
  <h3> Parsing the Input</h3>
  <p>I like to start by establishing a model and parsing the input.</p>
  <p>A <code>List</code> of <code>Integer</code>s is a natural way to
  model rotations. We’ll use <strong>positive integers</strong> for
  right rotations and <strong>negative integers</strong> for left
  rotations. This makes the math simpler later—we can just add the
  rotation value to our current position.</p>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb30"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">map</span> parseLine <span class="op">.</span> <span class="fu">lines</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    parseLine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    parseLine (<span class="ch">&#39;R&#39;</span><span class="op">:</span>rest) <span class="ot">=</span> <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> rest</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    parseLine (<span class="ch">&#39;L&#39;</span><span class="op">:</span>rest) <span class="ot">=</span> <span class="fu">negate</span> <span class="op">$</span> <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> rest</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    parseLine _ <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section class="lhs">
  <h3> Solving Part 1</h3>
  <p>To solve this, we’ll fold over the list of rotations while
  maintaining a tuple of <code>(count, currentRotation)</code>:</p>
  <ul>
  <li><code>count</code>: the number of times we’ve landed exactly on
  0</li>
  <li><code>currentRotation</code>: our current position on the
  dial</li>
  </ul>
  <p>The key insight: after each rotation, we check if our new position
  is divisible by 100 by using modulo (meaning we’re at position 0).</p>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb31"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>solvePart1 <span class="ot">=</span> <span class="fu">fst</span> <span class="op">.</span> foldl&#39; rotate (<span class="dv">0</span>, <span class="dv">50</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  rotate ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  rotate (count, currentRotation) rotation <span class="ot">=</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newRotation <span class="ot">=</span> currentRotation <span class="op">+</span> rotation</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>        isZero <span class="ot">=</span> newRotation <span class="ot">`mod`</span> <span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (count <span class="op">+</span> <span class="kw">if</span> isZero <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>, newRotation)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>All that’s left is to compose parsing with solving:</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb32"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 increases the difficulty: now we need to track how many
  times the indicator <strong>passes through</strong> position 0,
  including positions crossed during a rotation (not just where it
  lands).</p>
  <p>For example, if we’re at position 80 and rotate right by 30, we
  pass through position 0 once during that rotation (80 → 90 → 100/0 →
  10).</p>
  <p>[h3] The Algorithm</p>
  <p>The base algorithm remains a fold over the rotation list, but now
  we need a more sophisticated way to count zero crossings:</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb33"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>solvePart2 rotations <span class="ot">=</span> <span class="fu">fst</span> <span class="op">$</span> foldl&#39; go (<span class="dv">0</span>, <span class="dv">50</span>) rotations</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  go ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  go (count, currentRotation) rotation <span class="ot">=</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newRotation <span class="ot">=</span> currentRotation <span class="op">+</span> rotation</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>        clicks <span class="ot">=</span> numberOfClicks currentRotation rotation</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (count <span class="op">+</span> clicks, newRotation)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section class="lhs">
  <h3> Counting Zero Crossings</h3>
  <p>The <code>numberOfClicks</code> function calculates how many times
  we pass through zero during a single rotation.</p>
  <p>The logic breaks down as follows:</p>
  <ol type="1">
  <li><strong>Normalize the current position</strong> to be in range [0,
  99]</li>
  <li><strong>Calculate complete rotations</strong>: Dividing the
  rotation amount by 100 gives us how many full loops around the dial we
  make (<code>totalRotations</code>)</li>
  <li><strong>Check the remainder</strong>: After the complete
  rotations, does the remainder push us through 0?
  <ul>
  <li><strong>Right rotation</strong>: We pass through 0 if
  <code>currentPos + remainder &gt;= 100</code></li>
  <li><strong>Left rotation</strong>: We pass through 0 if we’re not
  already at 0 and <code>currentPos - remainder &lt;= 0</code></li>
  </ul></li>
  </ol>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb34"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">numberOfClicks ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>numberOfClicks pos rotation <span class="ot">=</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> actualPos <span class="ot">=</span> normalizeRotation pos</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>      (totalRotations, remainder) <span class="ot">=</span> <span class="fu">quotRem</span> (<span class="fu">abs</span> rotation) <span class="dv">100</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>      remainderClicks <span class="ot">=</span> <span class="kw">if</span> rotation <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> actualPos <span class="op">+</span> remainder <span class="op">&gt;=</span> <span class="dv">100</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> actualPos <span class="op">/=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> actualPos <span class="op">-</span> remainder <span class="op">&lt;=</span> <span class="dv">0</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> totalRotations <span class="op">+</span> <span class="kw">if</span> remainderClicks <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section class="lhs">
  <h3> Handling Negative Positions</h3>
  <p>One edge case: Haskell’s <code>mod</code> operator doesn’t wrap
  negative numbers the way we need for a circular dial. We need a custom
  normalization function: This ensures that <code>-10</code> becomes
  <code>90</code>, <code>-110</code> becomes <code>90</code>, etc.</p>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb35"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ot">normalizeRotation ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>normalizeRotation n</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> n <span class="op">&gt;=</span> <span class="dv">0</span>    <span class="ot">=</span> n <span class="ot">`mod`</span> <span class="dv">100</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> (<span class="dv">100</span> <span class="op">-</span> (<span class="fu">abs</span> n) <span class="ot">`mod`</span> <span class="dv">100</span>) <span class="ot">`mod`</span> <span class="dv">100</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section class="lhs">
  <h3> Final Solution</h3>
  <p>And TA-DA!</p>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb36"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>

    <script>
    // TOC Theme Toggle
    (function () {
      const toc = document.getElementById('TOC');
      const toggle = document.getElementById('theme-toggle');
      const icon = document.querySelector('.theme-icon');

      if (!toc || !toggle || !icon) return;

      // Load saved theme preference
      const savedTheme = localStorage.getItem('tocTheme') || 'light';
      if (savedTheme === 'dark') {
        toc.classList.add('dark-theme');
        icon.textContent = '🌙';
      }

      // Toggle theme on click
      toggle.addEventListener('click', function () {
        toc.classList.toggle('dark-theme');
        const isDark = toc.classList.contains('dark-theme');
        icon.textContent = isDark ? '🌙' : '☀️';
        localStorage.setItem('tocTheme', isDark ? 'dark' : 'light');
      });
    })();
  </script>
</body>

</html>
