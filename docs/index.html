<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet">
  <title>Day01</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { font-weight: bold; } /* Alert */
    code span.an { font-style: italic; } /* Annotation */
    code span.cf { font-weight: bold; } /* ControlFlow */
    code span.co { font-style: italic; } /* Comment */
    code span.cv { font-style: italic; } /* CommentVar */
    code span.do { font-style: italic; } /* Documentation */
    code span.er { font-weight: bold; } /* Error */
    code span.in { font-style: italic; } /* Information */
    code span.kw { font-weight: bold; } /* Keyword */
    code span.pp { font-weight: bold; } /* Preprocessor */
    code span.wa { font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=Libre+Baskerville:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
</head>
<body>
    <header id="title-block-header">
      <div>
        <div class='header-title'>Advent of Code 2025</div>
        <div class='header-subtitle'>in Haskell</div>
        <div class='header-meta'>
          <div class='header-author'>by Hugo Vilela</div>
          <div class='header-date'>December 2025</div>
        </div>
      </div>
  </header>
    <nav id="TOC" role="doc-toc" class="row">
    <h2>Table of Contents:</h2>
    <ul>
    <li><a href="#day-1" id="toc-day-1">Day 1</a>
    <ul>
    <li><a href="#part-1" id="toc-part-1">Part 1</a></li>
    <li><a href="#part-2" id="toc-part-2">Part 2</a></li>
    </ul></li>
    <li><a href="#day-2" id="toc-day-2">Day 2</a>
    <ul>
    <li><a href="#part-1-1" id="toc-part-1-1">Part 1</a></li>
    <li><a href="#part-2-1" id="toc-part-2-1">Part 2</a></li>
    </ul></li>
    </ul>
  </nav>
  
  <h1 id="day-1">Day 1</h1>
  <h2 id="part-1">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today‚Äôs puzzle involves a combination lock with a rotating dial.
  We‚Äôre given a series of left (L) and right (R) rotations, and we need
  to count how many times the dial lands exactly on position 0 after
  completing each rotation.</p>
  <p>The dial has 100 positions (0-99) and starts at position 50.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb1"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>First, a few ceremonies‚Ä¶</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb2"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day01</span> <span class="kw">where</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section id="parsing-the-input" class="lhs">
  <h3>Parsing the Input</h3>
  <p>I like to start by establishing a model and parsing the input.</p>
  <p>A <code>List</code> of <code>Integer</code>s is a natural way to
  model rotations. We‚Äôll use <strong>positive integers</strong> for
  right rotations and <strong>negative integers</strong> for left
  rotations. This makes the math simpler later‚Äîwe can just add the
  rotation value to our current position.</p>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb3"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">map</span> parseLine <span class="op">.</span> <span class="fu">lines</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    parseLine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    parseLine (<span class="ch">&#39;R&#39;</span><span class="op">:</span>rest) <span class="ot">=</span> <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> rest</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    parseLine (<span class="ch">&#39;L&#39;</span><span class="op">:</span>rest) <span class="ot">=</span> <span class="fu">negate</span> <span class="op">$</span> <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> rest</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    parseLine _ <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section id="solving-part-1" class="lhs">
  <h3>Solving Part 1</h3>
  <p>To solve this, we‚Äôll fold over the list of rotations while
  maintaining a tuple of <code>(count, currentRotation)</code>:</p>
  <ul>
  <li><code>count</code>: the number of times we‚Äôve landed exactly on
  0</li>
  <li><code>currentRotation</code>: our current position on the
  dial</li>
  </ul>
  <p>The key insight: after each rotation, we check if our new position
  is divisible by 100 by using modulo (meaning we‚Äôre at position 0).</p>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb4"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>solvePart1 <span class="ot">=</span> <span class="fu">fst</span> <span class="op">.</span> foldl&#39; rotate (<span class="dv">0</span>, <span class="dv">50</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  rotate ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  rotate (count, currentRotation) rotation <span class="ot">=</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newRotation <span class="ot">=</span> currentRotation <span class="op">+</span> rotation</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        isZero <span class="ot">=</span> newRotation <span class="ot">`mod`</span> <span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (count <span class="op">+</span> <span class="kw">if</span> isZero <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>, newRotation)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>All that‚Äôs left is to compose parsing with solving:</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb5"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 increases the difficulty: now we need to track how many
  times the indicator <strong>passes through</strong> position 0,
  including positions crossed during a rotation (not just where it
  lands).</p>
  <p>For example, if we‚Äôre at position 80 and rotate right by 30, we
  pass through position 0 once during that rotation (80 ‚Üí 90 ‚Üí 100/0 ‚Üí
  10).</p>
  <h3 id="the-algorithm">The Algorithm</h3>
  <p>The base algorithm remains a fold over the rotation list, but now
  we need a more sophisticated way to count zero crossings:</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb6"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>solvePart2 rotations <span class="ot">=</span> <span class="fu">fst</span> <span class="op">$</span> foldl&#39; go (<span class="dv">0</span>, <span class="dv">50</span>) rotations</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  go ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  go (count, currentRotation) rotation <span class="ot">=</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newRotation <span class="ot">=</span> currentRotation <span class="op">+</span> rotation</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        clicks <span class="ot">=</span> numberOfClicks currentRotation rotation</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (count <span class="op">+</span> clicks, newRotation)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section id="counting-zero-crossings" class="lhs">
  <h3>Counting Zero Crossings</h3>
  <p>The <code>numberOfClicks</code> function calculates how many times
  we pass through zero during a single rotation.</p>
  <p>The logic breaks down as follows:</p>
  <ol type="1">
  <li><strong>Normalize the current position</strong> to be in range [0,
  99]</li>
  <li><strong>Calculate complete rotations</strong>: Dividing the
  rotation amount by 100 gives us how many full loops around the dial we
  make (<code>totalRotations</code>)</li>
  <li><strong>Check the remainder</strong>: After the complete
  rotations, does the remainder push us through 0?
  <ul>
  <li><strong>Right rotation</strong>: We pass through 0 if
  <code>currentPos + remainder &gt;= 100</code></li>
  <li><strong>Left rotation</strong>: We pass through 0 if we‚Äôre not
  already at 0 and <code>currentPos - remainder &lt;= 0</code></li>
  </ul></li>
  </ol>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb7"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">numberOfClicks ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>numberOfClicks pos rotation <span class="ot">=</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> actualPos <span class="ot">=</span> normalizeRotation pos</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>      (totalRotations, remainder) <span class="ot">=</span> <span class="fu">quotRem</span> (<span class="fu">abs</span> rotation) <span class="dv">100</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>      remainderClicks <span class="ot">=</span> <span class="kw">if</span> rotation <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> actualPos <span class="op">+</span> remainder <span class="op">&gt;=</span> <span class="dv">100</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> actualPos <span class="op">/=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> actualPos <span class="op">-</span> remainder <span class="op">&lt;=</span> <span class="dv">0</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> totalRotations <span class="op">+</span> <span class="kw">if</span> remainderClicks <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section id="handling-negative-positions" class="lhs">
  <h3>Handling Negative Positions</h3>
  <p>One edge case: Haskell‚Äôs <code>mod</code> operator doesn‚Äôt wrap
  negative numbers the way we need for a circular dial. We need a custom
  normalization function: This ensures that <code>-10</code> becomes
  <code>90</code>, <code>-110</code> becomes <code>90</code>, etc.</p>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb8"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">normalizeRotation ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>normalizeRotation n</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> n <span class="op">&gt;=</span> <span class="dv">0</span>    <span class="ot">=</span> n <span class="ot">`mod`</span> <span class="dv">100</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> (<span class="dv">100</span> <span class="op">-</span> (<span class="fu">abs</span> n) <span class="ot">`mod`</span> <span class="dv">100</span>) <span class="ot">`mod`</span> <span class="dv">100</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section id="final-solution" class="lhs">
  <h3>Final Solution</h3>
  <p>And TA-DA!</p>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb9"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-2">Day 2</h1>
  <h2 id="part-1-1">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today‚Äôs puzzle gives us a list of integer ranges (N-M) and asks us
  to count ‚Äúinvalid IDs‚Äù within those ranges. An ID is invalid if it‚Äôs a
  number where the first half equals the second half (e.g., 123123,
  7777, 9898).</p>
  <p>The key challenge: some ranges can be enormous (like
  101-9999999999), so we can‚Äôt just check every number individually.</p>
  <p>A few ceremonies:</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb10"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day02</span> <span class="kw">where</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;))</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sort, nub)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section id="parsing-the-input-1" class="lhs">
  <h3>Parsing the Input</h3>
  <p>As always, we start with parsing. The input is a comma-separated
  list of ranges (e.g., ‚Äú101-999,5000-10000‚Äù).</p>
  <p>A tuple is a natural fit for representing a range. I chose to parse
  into <code>(Text, Text)</code> rather than <code>(Int, Int)</code>
  because it makes it easier to work with the number lengths and
  manipulate the digits later.</p>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb11"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Range</span> a <span class="ot">=</span> (a, a)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> [<span class="dt">Range</span> <span class="dt">T.Text</span>]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> T.splitOn <span class="st">&quot;,&quot;</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> parseRange</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    parseRange str <span class="ot">=</span> <span class="kw">let</span> [a, b] <span class="ot">=</span> T.splitOn <span class="st">&quot;-&quot;</span> str</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">in</span> (a, b)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section id="the-clever-trick-think-by-length-not-by-value"
  class="lhs">
  <h3>The Clever Trick: Think by Length, Not by Value</h3>
  <p>Okay, time to think this through. Let‚Äôs say we have the range
  <code>(101-9999999999)</code>. That‚Äôs billions of numbers to check
  individually‚Äîway too slow!</p>
  <p><strong>Key insight</strong>: Instead of iterating through every
  number, we can group them by their <em>length</em> (number of
  digits).</p>
  <h4 id="why-this-works">Why This Works</h4>
  <ol type="1">
  <li><strong>Odd-length numbers can never be invalid</strong>: You
  can‚Äôt split 3 digits evenly (e.g., 100-999 are all valid)</li>
  <li><strong>For even-length numbers, we only need to check one
  half</strong>:
  <ul>
  <li>For 4-digit numbers like <code>9898</code>, we just need the
  2-digit number <code>98</code> and duplicate it</li>
  <li>For 6-digit numbers like <code>123123</code>, we just need
  <code>123</code> and duplicate it</li>
  </ul></li>
  </ol>
  <p>This reduces the search space dramatically! Instead of checking
  billions of numbers, we only generate the small set that could
  possibly be invalid.</p>
  <h4 id="the-algorithm-1">The Algorithm</h4>
  <p><strong><code>invalidIdsInRange</code></strong> finds all invalid
  IDs within a given range by:</p>
  <ol type="1">
  <li>Getting all even number-lengths within the range (e.g., for range
  10-100000, we check lengths 2, 4, 6)</li>
  <li>For each length, generating all possible invalid IDs of that
  length</li>
  <li>Filtering to keep only those within the actual range bounds</li>
  </ol>
  <p><strong><code>invalidIdsByNumLength</code></strong> is an infinite
  list indexed by number length. At each index, it contains all invalid
  IDs of that length. For example:</p>
  <ul>
  <li>Index 2: <code>[11, 22, 33, ..., 99]</code></li>
  <li>Index 6: <code>[100100, 101101, ..., 999999]</code></li>
  </ul>
  <p>Given a certain length (say 4), instead of going through each
  number and checking if it‚Äôs invalid, we generate all length 2 numbers
  (ie. [10-99]) and duplicate them (ie. 10 -&gt; 1010) and this is how
  we get all invalid ids for that length.</p>
  <blockquote>
  <p><strong>A word on infinite lists in haskell</strong></p>
  <p>Infinite lists are extremely useful in haskell as a way of
  memoisation for two reasons.</p>
  <ol type="1">
  <li>Because haskell is lazy it will only compute the values that we
  ask from the list.</li>
  <li>The second time we access a value from the list its already
  precomputed and is passed by reference</li>
  </ol>
  <p>If <code>invalidIdsByNumLength</code> was a function it would
  recompute every time it‚Äôs invoked. this way we‚Äôre able to reuse work
  that‚Äôs already been done.</p>
  </blockquote>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb12"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> T.pack</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> parse</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> <span class="fu">concatMap</span> invalidIdsInRange</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> <span class="fu">sum</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    invalidIdsInRange ::</span> <span class="dt">Range</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    invalidIdsInRange (a, b) <span class="ot">=</span> [T.length a <span class="op">..</span> T.length b]</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>                               <span class="op">&amp;</span> <span class="fu">filter</span> <span class="fu">even</span>                          <span class="co">-- Only even-length numbers (odd lengths can&#39;t be mirrored)</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>                               <span class="op">&amp;</span> <span class="fu">concatMap</span> (invalidIdsByNumLength <span class="op">!!</span>) <span class="co">-- Get all invalid IDs of these lengths</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>                               <span class="op">&amp;</span> <span class="fu">dropWhile</span> (<span class="op">&lt;</span> textRead <span class="op">@</span><span class="dt">Int</span> a)        <span class="co">-- Drop IDs below range start</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>                               <span class="op">&amp;</span> <span class="fu">takeWhile</span> (<span class="op">&lt;=</span> textRead <span class="op">@</span><span class="dt">Int</span> b)       <span class="co">-- Take only IDs within range end</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Infinite list of all possible invalid IDs by length</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="ot">    invalidIdsByNumLength ::</span> [[<span class="dt">Int</span>]]</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    invalidIdsByNumLength <span class="ot">=</span> [<span class="dv">0</span><span class="op">..</span>]</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">&amp;</span> <span class="fu">map</span> (</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- For each length, generate the first half and duplicate it</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- e.g., for length 4: take all 2-digit numbers [10..99] and duplicate to [1010..9999]</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>         <span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span>) <span class="op">.</span> <span class="fu">map</span> (\a <span class="ot">-&gt;</span> a <span class="op">&lt;&gt;</span> a) <span class="op">.</span> getNDigits <span class="op">.</span> (<span class="ot">`div`</span> <span class="dv">2</span>)</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>      )</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-1">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 raises the stakes! Now an invalid ID is <strong>any number
  that has a repeating pattern</strong> (a substring repeated 2 or more
  times).</p>
  <h3 id="examples-of-invalid-ids">Examples of Invalid IDs</h3>
  <ul>
  <li><code>111</code> (the digit ‚Äú1‚Äù repeated 3 times)</li>
  <li><code>10101010</code> (the substring ‚Äú10‚Äù repeated 4 times)</li>
  <li><code>125125</code> (the substring ‚Äú125‚Äù repeated 2 times)</li>
  <li><code>123123123</code> (the substring ‚Äú123‚Äù repeated 3 times)</li>
  </ul>
  <h3 id="the-approach-find-all-divisors">The Approach: Find All
  Divisors</h3>
  <p>My approach builds on Part 1: we still process numbers by their
  length. But now, for each length, we need to find <strong>all possible
  repeating patterns</strong>.</p>
  <p>The key insight: a repeating pattern of length N can only exist in
  a number of length L if N divides L evenly.</p>
  <p>For a 6-digit number, the divisors are 1, 2, and 3:</p>
  <table>
  <thead>
  <tr>
  <th>Divisor</th>
  <th>Pattern</th>
  <th>Example</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>1</td>
  <td><code>XXXXXX</code></td>
  <td><code>111111</code> (repeat ‚Äú1‚Äù six times)</td>
  </tr>
  <tr>
  <td>2</td>
  <td><code>XYXYXY</code></td>
  <td><code>121212</code> (repeat ‚Äú12‚Äù three times)</td>
  </tr>
  <tr>
  <td>3</td>
  <td><code>XYZXYZ</code></td>
  <td><code>123123</code> (repeat ‚Äú123‚Äù twice)</td>
  </tr>
  </tbody>
  </table>
  <p>Note: Divisor 6 doesn‚Äôt count because we need <strong>at least 2
  repetitions</strong>.</p>
  <h3 id="the-algorithm-2">The Algorithm</h3>
  <p><strong><code>invalidIdsByNumLength</code></strong> remains
  virtually the same</p>
  <p><strong><code>getInvalidIds</code></strong> does the heavy lifting
  for a single length:</p>
  <ol type="1">
  <li>Find all valid divisors (prefix lengths that divide evenly)</li>
  <li>For each divisor, generate all possible numbers of that
  length</li>
  <li>Repeat each number the appropriate number of times to fill the
  full length</li>
  <li>Combine, sort, and deduplicate all results to get a clean
  <code>[[Int]]</code></li>
  </ol>
  <h3 id="helper-functions">Helper Functions</h3>
  <ul>
  <li><strong><code>getNDigits n</code></strong>: Returns all n-digit
  numbers as strings (e.g.,
  <code>getNDigits 2 = ["10", "11", ..., "99"]</code>)</li>
  <li><strong><code>numLength</code></strong>: Returns the number of
  digits in a number (e.g., <code>numLength 100 = 3</code>)</li>
  <li><strong><code>textRead</code></strong>: Convenience function to
  read from Text</li>
  </ul>
  <p>This approach efficiently generates exactly the invalid IDs we need
  without checking every possible 6-digit number!</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb13"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> T.pack</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> parse</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> <span class="fu">concatMap</span> invalidIdsInRange</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> <span class="fu">sum</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    invalidIdsInRange ::</span> <span class="dt">Range</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    invalidIdsInRange (a, b) <span class="ot">=</span> [T.length a <span class="op">..</span> T.length b]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>                               <span class="op">&amp;</span> <span class="fu">concatMap</span> (invalidIdsByNumLength <span class="op">!!</span>)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>                               <span class="op">&amp;</span> <span class="fu">dropWhile</span> (<span class="op">&lt;</span> textRead <span class="op">@</span><span class="dt">Int</span> a)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>                               <span class="op">&amp;</span> <span class="fu">takeWhile</span> (<span class="op">&lt;=</span> textRead <span class="op">@</span><span class="dt">Int</span> b)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- List of invalid IDs by length of number</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="ot">    invalidIdsByNumLength ::</span> [[<span class="dt">Int</span>]]</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    invalidIdsByNumLength <span class="ot">=</span> [<span class="dv">0</span><span class="op">..</span>] <span class="op">&amp;</span> <span class="fu">map</span> getInvalidIds</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span> getInvalidIds numLen <span class="ot">=</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span> prefixLengths <span class="ot">=</span> <span class="fu">filter</span> (\prefixLen <span class="ot">-&gt;</span> numLen <span class="ot">`rem`</span> prefixLen <span class="op">==</span> <span class="dv">0</span>) [<span class="dv">1</span><span class="op">..</span>(numLen <span class="op">-</span> <span class="dv">1</span>)]</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>                  <span class="co">-- How many times we need to repeat a prefix to reach numLen</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>                  prefixRepeats prefixLen <span class="ot">=</span> numLen <span class="ot">`quot`</span> prefixLen</span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>                  invalidIds <span class="ot">=</span> prefixLengths</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- Generate all invalid IDs by repeating each possible prefix</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>                    <span class="op">&amp;</span> <span class="fu">map</span> (\prefixLen <span class="ot">-&gt;</span> <span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>                            <span class="op">.</span> <span class="fu">concat</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>                            <span class="op">.</span> <span class="fu">replicate</span> (prefixRepeats prefixLen))</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>                        <span class="op">$</span> getNDigits prefixLen)</span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>               <span class="kw">in</span> <span class="fu">sort</span> <span class="op">.</span> nub <span class="op">.</span> <span class="fu">concat</span> <span class="op">$</span> invalidIds</span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a><span class="ot">    numbersByLength ::</span> [[<span class="dt">Int</span>]]</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a>    numbersByLength <span class="ot">=</span> [<span class="dv">0</span><span class="op">..</span>] <span class="op">&amp;</span> <span class="fu">map</span> (<span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span>) <span class="op">.</span> getNDigits)</span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Get the number of digits in a number</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a><span class="co">-- e.g. numLength 100 = 3</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a><span class="ot">numLength ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>numLength <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">show</span></span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Returns all numbers with n digits in ascending order</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a><span class="co">-- e.g. getNDigits 2 = [&quot;10&quot;, &quot;11&quot;, ..., &quot;99&quot;]</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a><span class="ot">getNDigits ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">Char</span>]]</span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a>getNDigits numChars <span class="ot">=</span></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> first <span class="ot">=</span> [<span class="ch">&#39;1&#39;</span><span class="op">..</span><span class="ch">&#39;9&#39;</span>]      <span class="co">-- First digit can&#39;t be 0</span></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>      other <span class="ot">=</span> [<span class="ch">&#39;0&#39;</span><span class="op">..</span><span class="ch">&#39;9&#39;</span>]      <span class="co">-- Other digits can be anything</span></span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a>      <span class="fu">all</span> <span class="ot">=</span> first <span class="op">:</span> <span class="fu">replicate</span> (numChars <span class="op">-</span> <span class="dv">1</span>) other</span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="fu">map</span> <span class="fu">reverse</span> <span class="op">$</span> foldl&#39; go ([<span class="st">&quot;&quot;</span>]) <span class="fu">all</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>   <span class="kw">where</span></span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>    go acc digits <span class="ot">=</span> <span class="fu">flip</span> <span class="fu">concatMap</span> acc <span class="op">$</span> \str <span class="ot">-&gt;</span> <span class="fu">map</span> (<span class="op">:</span>str) digits</span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a><span class="ot">textRead ::</span> (<span class="dt">Read</span> a) <span class="ot">=&gt;</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> a</span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a>textRead <span class="ot">=</span> <span class="fu">read</span> <span class="op">.</span> T.unpack</span></code></pre></div>
  </div>
  </div>

    <script>
    // TOC Theme Toggle
    (function() {
      const toc = document.getElementById('TOC');
      const toggle = document.getElementById('theme-toggle');
      const icon = document.querySelector('.theme-icon');

      if (!toc || !toggle || !icon) return;

      // Load saved theme preference
      const savedTheme = localStorage.getItem('tocTheme') || 'light';
      if (savedTheme === 'dark') {
        toc.classList.add('dark-theme');
        icon.textContent = 'üåô';
      }

      // Toggle theme on click
      toggle.addEventListener('click', function() {
        toc.classList.toggle('dark-theme');
        const isDark = toc.classList.contains('dark-theme');
        icon.textContent = isDark ? 'üåô' : '‚òÄÔ∏è';
        localStorage.setItem('tocTheme', isDark ? 'dark' : 'light');
      });
    })();
  </script>
</body>
</html>
