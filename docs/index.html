<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="" >

<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap"
    rel="stylesheet">
          <title>Day01</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { font-weight: bold; } /* Alert */
    code span.an { font-style: italic; } /* Annotation */
    code span.cf { font-weight: bold; } /* ControlFlow */
    code span.co { font-style: italic; } /* Comment */
    code span.cv { font-style: italic; } /* CommentVar */
    code span.do { font-style: italic; } /* Documentation */
    code span.er { font-weight: bold; } /* Error */
    code span.in { font-style: italic; } /* Information */
    code span.kw { font-weight: bold; } /* Keyword */
    code span.pp { font-weight: bold; } /* Preprocessor */
    code span.wa { font-style: italic; } /* Warning */
  </style>
    <link rel="stylesheet" href="style.css" />
        <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=Libre+Baskerville:ital,wght@0,400..700;1,400..700&display=swap"
    rel="stylesheet">
</head>

<body>
    <header id="title-block-header">
    <div>
      <div class='header-title'>Advent of Code 2025</div>
      <div class='header-subtitle'>in Haskell</div>
      <div class='header-meta'>
        <div class='header-author'>by Hugo Vilela</div>
        <div class='header-date'>December 2025</div>
        <div class='header-credits'>based on 
          <a target="_blank" href="https://aoc.oppi.li/">The Book of Solves</a>
          by <a target="_blank" href="https://tangled.org/oppi.li">@oppi.li</a>

        </div>
      </div>
    </div>
  </header>
    <nav id="TOC" role="doc-toc">
    <h2>Table of Contents:</h2>
    <ul>
    <li><a href="#day-1" id="toc-day-1">Day 1</a>
    <ul>
    <li><a href="#part-1" id="toc-part-1">Part 1</a></li>
    <li><a href="#part-2" id="toc-part-2">Part 2</a></li>
    </ul></li>
    <li><a href="#day-2" id="toc-day-2">Day 2</a>
    <ul>
    <li><a href="#part-1-1" id="toc-part-1-1">Part 1</a></li>
    <li><a href="#part-2-1" id="toc-part-2-1">Part 2</a></li>
    </ul></li>
    <li><a href="#day-3" id="toc-day-3">Day 3</a>
    <ul>
    <li><a href="#part-1-2" id="toc-part-1-2">Part 1</a></li>
    <li><a href="#part-2-2" id="toc-part-2-2">Part 2</a></li>
    </ul></li>
    <li><a href="#day-4" id="toc-day-4">Day 4</a>
    <ul>
    <li><a href="#part-1-3" id="toc-part-1-3">Part 1</a></li>
    <li><a href="#part-2-3" id="toc-part-2-3">Part 2</a></li>
    </ul></li>
    <li><a href="#day-5" id="toc-day-5">Day 5</a>
    <ul>
    <li><a href="#part-1-4" id="toc-part-1-4">Part 1</a></li>
    <li><a href="#part-2-4" id="toc-part-2-4">Part 2</a></li>
    </ul></li>
    <li><a href="#day-6" id="toc-day-6">Day 6</a>
    <ul>
    <li><a href="#part-1-5" id="toc-part-1-5">Part 1</a></li>
    <li><a href="#part-2-5" id="toc-part-2-5">Part 2</a></li>
    </ul></li>
    <li><a href="#day-7" id="toc-day-7">Day 7</a>
    <ul>
    <li><a href="#part-1-6" id="toc-part-1-6">Part 1</a></li>
    <li><a href="#part-2-6" id="toc-part-2-6">Part 2</a></li>
    </ul></li>
    <li><a href="#day-8" id="toc-day-8">Day 8</a>
    <ul>
    <li><a href="#part-1-7" id="toc-part-1-7">Part 1</a></li>
    <li><a href="#part-2-7" id="toc-part-2-7">Part 2</a></li>
    </ul></li>
    <li><a href="#day-9" id="toc-day-9">Day 9</a>
    <ul>
    <li><a href="#part-1-8" id="toc-part-1-8">Part 1</a></li>
    <li><a href="#part-2-8" id="toc-part-2-8">Part 2</a></li>
    </ul></li>
    <li><a href="#day-10" id="toc-day-10">Day 10</a>
    <ul>
    <li><a href="#part-1-9" id="toc-part-1-9">Part 1</a></li>
    <li><a href="#part-2-9" id="toc-part-2-9">Part 2</a></li>
    </ul></li>
    </ul>
  </nav>
  
  <h1 id="day-1">Day 1</h1>
  <h2 id="part-1">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle involves a combination lock with a rotating dial.
  We’re given a series of left (L) and right (R) rotations, and we need
  to count how many times the dial lands exactly on position 0 after
  completing each rotation.</p>
  <p>The dial has 100 positions (0-99) and starts at position 50.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb1"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day01</span> <span class="kw">where</span></span></code></pre></div>
  </div>
  </div>
  <h3> Parsing the Input</h3>
  <div class="row">
  <div class="lhs">
  <p>Let’s start by modeling the problem. A list of integers is perfect
  for representing rotations—we’ll use <strong>positive
  integers</strong> for right rotations and <strong>negative
  integers</strong> for left rotations. This lets us simply add the
  rotation value to our current position without branching logic.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb2"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">map</span> parseLine <span class="op">.</span> <span class="fu">lines</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    parseLine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    parseLine (<span class="ch">&#39;R&#39;</span><span class="op">:</span>rest) <span class="ot">=</span> <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> rest</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    parseLine (<span class="ch">&#39;L&#39;</span><span class="op">:</span>rest) <span class="ot">=</span> <span class="fu">negate</span> <span class="op">$</span> <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> rest</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    parseLine _ <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
  </div>
  </div>
  <h3> Solving Part 1</h3>
  <div class="row">
  <div class="lhs">
  <p>To solve this, we’ll fold over the list of rotations while
  maintaining a tuple of <code>(count, currentRotation)</code>:</p>
  <ul>
  <li><code>count</code>: the number of times we’ve landed exactly on
  0</li>
  <li><code>currentRotation</code>: our current position on the
  dial</li>
  </ul>
  <p>After each rotation, we check if our new position modulo 100 equals
  0—meaning we’ve landed precisely on position 0.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb3"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>solvePart1 <span class="ot">=</span> <span class="fu">fst</span> <span class="op">.</span> foldl&#39; rotate (<span class="dv">0</span>, <span class="dv">50</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  rotate ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  rotate (count, currentRotation) rotation <span class="ot">=</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newRotation <span class="ot">=</span> currentRotation <span class="op">+</span> rotation</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        isZero <span class="ot">=</span> newRotation <span class="ot">`mod`</span> <span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (count <span class="op">+</span> <span class="kw">if</span> isZero <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>, newRotation)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>All that’s left is to compose parsing with solving:</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb4"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 increases the difficulty: now we need to track how many
  times the indicator <strong>passes through</strong> position 0,
  including positions crossed during a rotation (not just where it
  lands).</p>
  <p>For example, if we’re at position 80 and rotate right by 30, we
  pass through position 0 once during that rotation (80 → 90 → 100/0 →
  10).</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The Algorithm</h3>
  <div class="row">
  <div class="lhs">
  <p>The base algorithm remains a fold over the rotation list, but now
  we need a more sophisticated way to count zero crossings:</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb5"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>solvePart2 rotations <span class="ot">=</span> <span class="fu">fst</span> <span class="op">$</span> foldl&#39; go (<span class="dv">0</span>, <span class="dv">50</span>) rotations</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  go ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  go (count, currentRotation) rotation <span class="ot">=</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newRotation <span class="ot">=</span> currentRotation <span class="op">+</span> rotation</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        clicks <span class="ot">=</span> numberOfClicks currentRotation rotation</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (count <span class="op">+</span> clicks, newRotation)</span></code></pre></div>
  </div>
  </div>
  <h3> Counting Zero Crossings</h3>
  <div class="row">
  <div class="lhs">
  <p>The <code>numberOfClicks</code> function calculates how many times
  we pass through zero during a single rotation.</p>
  <p>The logic breaks down as follows:</p>
  <ol type="1">
  <li><strong>Normalize the current position</strong> to be in range [0,
  99]</li>
  <li><strong>Calculate complete rotations</strong>: Dividing the
  rotation amount by 100 gives us how many full loops around the dial we
  make (<code>totalRotations</code>)</li>
  <li><strong>Check the remainder</strong>: After the complete
  rotations, does the remainder push us through 0?
  <ul>
  <li><strong>Right rotation</strong>: We pass through 0 if
  <code>currentPos + remainder &gt;= 100</code></li>
  <li><strong>Left rotation</strong>: We pass through 0 if we’re not
  already at 0 and <code>currentPos - remainder &lt;= 0</code></li>
  </ul></li>
  </ol>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb6"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">numberOfClicks ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>numberOfClicks pos rotation <span class="ot">=</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> actualPos <span class="ot">=</span> normalizeRotation pos</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>      (totalRotations, remainder) <span class="ot">=</span> <span class="fu">quotRem</span> (<span class="fu">abs</span> rotation) <span class="dv">100</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>      remainderClicks <span class="ot">=</span> <span class="kw">if</span> rotation <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> actualPos <span class="op">+</span> remainder <span class="op">&gt;=</span> <span class="dv">100</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> actualPos <span class="op">/=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> actualPos <span class="op">-</span> remainder <span class="op">&lt;=</span> <span class="dv">0</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> totalRotations <span class="op">+</span> <span class="kw">if</span> remainderClicks <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span></code></pre></div>
  </div>
  </div>
  <h3> Handling Negative Positions</h3>
  <div class="row">
  <div class="lhs">
  <p>One important edge case: Haskell’s <code>mod</code> operator
  doesn’t wrap negative numbers the way we need for a circular dial. Our
  custom normalization function ensures that <code>-10</code> becomes
  <code>90</code>, <code>-110</code> becomes <code>90</code>, and so
  on—wrapping properly in the reverse direction.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb7"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">normalizeRotation ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>normalizeRotation n</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> n <span class="op">&gt;=</span> <span class="dv">0</span>    <span class="ot">=</span> n <span class="ot">`mod`</span> <span class="dv">100</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> (<span class="dv">100</span> <span class="op">-</span> (<span class="fu">abs</span> n) <span class="ot">`mod`</span> <span class="dv">100</span>) <span class="ot">`mod`</span> <span class="dv">100</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>With all the pieces in place, Part 2 comes together:</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb8"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-2">Day 2</h1>
  <h2 id="part-1-1">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle gives us a list of numeric ranges:</p>
  <div class="sourceCode" id="cb9"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(90 - 10000)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>(57 - 82345)</span></code></pre></div>
  <p>Our task: find all “invalid IDs” within each range and sum them
  together.</p>
  <p>An ID is invalid if its digits can be split into two equal halves.
  For example:</p>
  <ul>
  <li><code>1010</code> splits into <code>10</code> and <code>10</code>
  ✓ invalid</li>
  <li><code>123123</code> splits into <code>123</code> and
  <code>123</code> ✓ invalid</li>
  <li><code>88</code> splits into <code>8</code> and <code>8</code> ✓
  invalid</li>
  <li><code>123</code> has odd length ✗ valid</li>
  <li><code>1234</code> splits into <code>12</code> and <code>34</code>
  ✗ valid</li>
  </ul>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb10"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day02</span> <span class="kw">where</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;))</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.Split</span> (chunksOf)</span></code></pre></div>
  </div>
  </div>
  <h3> Parsing</h3>
  <div class="row">
  <div class="lhs">
  <p>The input is comma-separated ranges, which we’ll model as pairs of
  integers.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb11"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Range</span> <span class="ot">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Range</span>]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> T.pack <span class="op">&gt;&gt;&gt;</span> T.splitOn <span class="st">&quot;,&quot;</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> parseRange</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    parseRange str <span class="ot">=</span> <span class="kw">let</span> [a, b] <span class="ot">=</span> T.splitOn <span class="st">&quot;-&quot;</span> str</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">in</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> <span class="op">$</span> T.unpack a, <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> <span class="op">$</span> T.unpack b)</span></code></pre></div>
  </div>
  </div>
  <h3> The Solution</h3>
  <div class="row">
  <div class="lhs">
  <p>The algorithm is straightforward: for each range, check every
  number to see if it’s invalid, sum those that are, then sum across all
  ranges.</p>
  <p>The <code>isInvalid</code> function checks if a number has even
  digit length and whether its first half equals its second half.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb12"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> parse <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> invalidIdsInRange <span class="op">&gt;&gt;&gt;</span> <span class="fu">sum</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    invalidIdsInRange ::</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    invalidIdsInRange (a, b) <span class="ot">=</span> <span class="fu">sum</span> <span class="op">$</span> <span class="fu">filter</span> isInvalid <span class="op">$</span> [a<span class="op">..</span>b]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    isInvalid ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    isInvalid n <span class="ot">=</span> <span class="kw">let</span> str <span class="ot">=</span> <span class="fu">show</span> n</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>                      [<span class="fu">fst</span>, <span class="fu">snd</span>] <span class="ot">=</span> chunksOf (<span class="fu">length</span> str <span class="ot">`div`</span> <span class="dv">2</span>) str</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">in</span> <span class="fu">even</span> (<span class="fu">length</span> str) <span class="op">&amp;&amp;</span> <span class="fu">fst</span> <span class="op">==</span> <span class="fu">snd</span></span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-1">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 generalizes the pattern: now an ID is invalid if it consists
  of any repeating segment, not just two halves. For example:</p>
  <ul>
  <li><code>111</code> → <code>1</code> repeated 3 times ✓ invalid</li>
  <li><code>123123123</code> → <code>123</code> repeated 3 times ✓
  invalid</li>
  <li><code>88</code> → <code>8</code> repeated 2 times ✓ invalid</li>
  <li><code>1234</code> → no repeating pattern ✗ valid</li>
  </ul>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The Key Insight</h3>
  <div class="row">
  <div class="lhs">
  <p>We need to find all possible chunk sizes that could divide the
  number evenly, then check if chunking by that size produces identical
  chunks.</p>
  <p>For a number with length 6, we check chunk sizes 1, 2, and 3
  (divisors of 6). If any chunking produces all-equal chunks, the number
  is invalid.</p>
  <p>The implementation changes only the <code>isInvalid</code>
  function—everything else stays the same.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb13"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> parse <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> invalidIdsInRange <span class="op">&gt;&gt;&gt;</span> <span class="fu">sum</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  invalidIdsInRange ::</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  invalidIdsInRange (a, b) <span class="ot">=</span> <span class="fu">sum</span> <span class="op">$</span> <span class="fu">filter</span> isInvalid <span class="op">$</span> [a<span class="op">..</span>b]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  isInvalid ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  isInvalid n <span class="ot">=</span> <span class="kw">let</span> str <span class="ot">=</span> <span class="fu">show</span> n</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>                    divs <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span><span class="fu">length</span> str <span class="ot">`div`</span> <span class="dv">2</span>] <span class="op">&amp;</span> <span class="fu">filter</span> (\it <span class="ot">-&gt;</span> <span class="fu">length</span> str <span class="ot">`mod`</span> it <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span> <span class="fu">any</span> (allEqual <span class="op">.</span> <span class="fu">flip</span> chunksOf str) divs</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="ot">allEqual ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>allEqual (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">all</span> (<span class="op">==</span> x) xs</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>allEqual [] <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
  </div>
  </div>
  <h1 id="day-3">Day 3</h1>
  <h2 id="part-1-2">Part 1</h2>
  <h3> The Problem</h3>
  <div class="row">
  <div class="lhs">
  <p>Today’s input gives us rows of digits—think of each row as a “bank
  of batteries”:</p>
  <div class="sourceCode" id="cb14"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>987654321111111</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>811111111111119</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>234234234234278</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>818181911112111</span></code></pre></div>
  <p>Each digit represents a battery, and our job is to calculate the
  maximum “joltage” for each bank, then sum them all together.</p>
  <p>For Part 1, the joltage of a bank is determined by picking any two
  digits (in order, no reversing) and forming a two-digit number. For
  example, from <code>987654321111111</code>, we could pick the
  <code>9</code> and <code>8</code> to get <code>98</code>, or the
  <code>9</code> and <code>7</code> to get <code>97</code>. The maximum
  joltage is the largest such number we can form.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb15"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TupleSections #-}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day03</span> <span class="kw">where</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;), on)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span> (<span class="dt">Foldable</span>(foldMap&#39;))</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span> (<span class="dt">Sum</span>(<span class="dt">Sum</span>, getSum))</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sortBy)</span></code></pre></div>
  </div>
  </div>
  <h3> The Solution</h3>
  <div class="row">
  <div class="lhs">
  <p>Our data model is simple: a list of banks, where each bank is a
  list of digit values.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb16"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Bank</span> <span class="ot">=</span> [<span class="dt">Int</span>]</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Parsing is straightforward—we split into lines and convert each
  character to a single digit.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb17"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">lines</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> <span class="op">.</span> (<span class="op">:</span>[])))</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The algorithm: generate all possible pairs of digits (maintaining
  order), form two-digit numbers from each pair, and take the maximum.
  Sum across all banks for the final answer.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb18"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solve <span class="op">.</span> parse</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    solve ::</span> [<span class="dt">Bank</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    solve <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> getBankJoltage</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    getBankJoltage ::</span> <span class="dt">Bank</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    getBankJoltage <span class="ot">=</span> <span class="fu">maximum</span> <span class="op">.</span> allJoltagesInBank</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    allJoltagesInBank ::</span> <span class="dt">Bank</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    allJoltagesInBank <span class="ot">=</span> <span class="fu">map</span> (\(a, b) <span class="ot">-&gt;</span> a <span class="op">*</span> <span class="dv">10</span> <span class="op">+</span> b) <span class="op">.</span> batteryPairs</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    batteryPairs ::</span> <span class="dt">Bank</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    batteryPairs (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">map</span> (x,) xs <span class="op">&lt;&gt;</span> batteryPairs xs</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    batteryPairs [] <span class="ot">=</span> []</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-2">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 escalates things: now we need to pick <strong>12
  digits</strong> to form a 12-digit number, and maximize
  <em>that</em>.</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The Greedy Insight</h3>
  <div class="row">
  <div class="lhs">
  <p>Here’s the key insight: we can solve this greedily by picking
  digits from most significant to least significant.</p>
  <p>Let’s think through a simpler example: picking 4 digits from a
  6-digit bank. The first digit we pick can’t be in the last 3
  positions—we need to leave room for the 3 digits that follow. Among
  the valid positions (first 3 positions), we pick the largest
  digit.</p>
  <p>If there’s a tie, we pick the <em>earliest</em> occurrence. Why?
  Because choosing earlier gives us more options for subsequent
  digits—we preserve flexibility down the line.</p>
  <p>Once we’ve picked the first digit, we repeat the process for the
  second digit (starting from just after our first pick), then the
  third, and so on.</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> Implementation</h3>
  <div class="row">
  <div class="lhs">
  <p>The structure mirrors Part 1, except we use
  <code>getMaxJoltageOf</code> to generalize to any number of digits (12
  in this case).</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb19"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | The solution for part2 is more efficient and could be used for part1 by using (getMaxJoltageOf 2)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solve <span class="op">.</span> parse</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    solve ::</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    solve <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> (getMaxJoltageOf <span class="dv">12</span>)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The <code>getMaxJoltageOf</code> function implements our greedy
  strategy. For each digit position, we calculate which indices in the
  original bank are valid candidates (ensuring we leave enough room for
  remaining digits), then pick the largest digit from those
  positions.</p>
  <p>The recursion tracks three things: how many digits we’ve picked so
  far, the minimum index we can pick from (to maintain order), and our
  accumulated result.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb20"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- |returns the max joltage of taking `size` batteries in a bank</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    getMaxJoltageOf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    getMaxJoltageOf size digits <span class="ot">=</span> mergeDigits <span class="op">$</span> <span class="fu">reverse</span> <span class="op">$</span> go <span class="dv">0</span> <span class="dv">0</span> []</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="ot">        go ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        go n _ acc <span class="op">|</span> n <span class="op">==</span> size <span class="ot">=</span> acc</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- | recursively find the next best digit</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- when picking a digit we know what positions in the original array are valid</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- we pick the greatest digit and if there are multiple we pick the first</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        go ix <span class="fu">minBound</span> acc <span class="ot">=</span> <span class="kw">let</span> digitBounds <span class="ot">=</span> [<span class="fu">minBound</span><span class="op">..</span>(<span class="fu">length</span> digits <span class="op">-</span> size <span class="op">+</span> ix)]</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>                                 (maxDigitIx, maxDigit) <span class="ot">=</span> <span class="fu">head</span> <span class="op">.</span> sortBy (<span class="fu">compare</span> <span class="ot">`on`</span> <span class="fu">negate</span> <span class="op">.</span> <span class="fu">snd</span>) <span class="op">$</span> <span class="fu">map</span> (\(ix, ix2) <span class="ot">-&gt;</span> (ix, digits<span class="op">!!</span>ix2)) <span class="op">$</span> <span class="fu">zip</span> digitBounds digitBounds</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>                              <span class="kw">in</span> go (ix <span class="op">+</span> <span class="dv">1</span>) (maxDigitIx <span class="op">+</span><span class="dv">1</span>) (maxDigit<span class="op">:</span>acc)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Finally, we need to merge our list of digits into an actual number.
  We reverse the list (since we built it backwards), then combine digits
  by multiplying each by the appropriate power of 10 based on its
  position.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb21"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Merges digits into number.</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- mergeDigits [1, 2, 3] === 123</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ot">mergeDigits ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>mergeDigits xs <span class="ot">=</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] (<span class="fu">reverse</span> xs)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> foldMap&#39; (\(ix, d) <span class="ot">-&gt;</span> <span class="dt">Sum</span> (d <span class="op">*</span> <span class="dv">10</span> <span class="op">^</span> ix))</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> getSum</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-4">Day 4</h1>
  <h2 id="part-1-3">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle presents us with a 2D grid containing rolls of paper
  (marked with <code>@</code>) scattered among empty spaces.</p>
  <p>Our task: count how many rolls are <strong>accessible</strong>. A
  roll is accessible if it has fewer than 4 neighboring rolls in the 8
  adjacent positions (including diagonals). In other words, rolls that
  are too crowded (4+ neighbors) are inaccessible.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb22"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TupleSections #-}</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day04</span> <span class="kw">where</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashSet</span> (<span class="dt">HashSet</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.HashSet</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Linear.V2</span></span></code></pre></div>
  </div>
  </div>
  <h3> Data Representation</h3>
  <div class="row">
  <div class="lhs">
  <p>We’ll use <code>V2 Int</code> from the <code>linear</code> package
  to represent positions, and a <code>HashSet</code> to store the
  grid.</p>
  <p>Since we only care about where the rolls are (not empty spaces), we
  store just the positions containing rolls. This gives us efficient
  O(1) average-case lookups to check “is there a roll at this
  position?”</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb23"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Position</span> <span class="ot">=</span> <span class="dt">V2</span> <span class="dt">Int</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Grid</span> <span class="ot">=</span> <span class="dt">HashSet</span> <span class="dt">Position</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Grid</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>parse str <span class="ot">=</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  Set.fromList <span class="op">$</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    [ pos</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> (lineIx, line) <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] (<span class="fu">lines</span> str)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    , (colIx, char) <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] line</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    , <span class="kw">let</span> pos <span class="ot">=</span> <span class="dt">V2</span> lineIx colIx</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    , char <span class="op">==</span> <span class="ch">&#39;@&#39;</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    ]</span></code></pre></div>
  </div>
  </div>
  <h3> The Solution</h3>
  <div class="row">
  <div class="lhs">
  <p>The solution filters the grid to keep only rolls with fewer than 4
  neighbors, then counts them.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb24"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> <span class="dt">Grid</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>solvePart1 grid <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> Set.filter ((<span class="op">&lt;</span><span class="dv">4</span>) <span class="op">.</span> getAdjacentRolls grid) <span class="op">$</span> grid</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The <code>getAdjacentRolls</code> helper generates all 8 adjacent
  positions (using vector addition) and counts how many contain
  rolls.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb25"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getAdjacentRolls ::</span> <span class="dt">Grid</span> <span class="ot">-&gt;</span> <span class="dt">Position</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>getAdjacentRolls grid pos <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="ot">`Set.member`</span> grid) <span class="op">.</span> <span class="fu">map</span> (pos <span class="op">+</span>) <span class="op">$</span> adjacentVectors</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    adjacentVectors ::</span> [<span class="dt">V2</span> <span class="dt">Int</span>]</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    adjacentVectors <span class="ot">=</span> [<span class="dt">V2</span> a b <span class="op">|</span> a <span class="ot">&lt;-</span> [<span class="op">-</span><span class="dv">1</span><span class="op">..</span><span class="dv">1</span>], b <span class="ot">&lt;-</span> [<span class="op">-</span><span class="dv">1</span><span class="op">..</span><span class="dv">1</span>], a <span class="op">/=</span> <span class="dv">0</span> <span class="op">||</span> b <span class="op">/=</span><span class="dv">0</span> ]</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-3">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 introduces a removal process: we repeatedly remove all
  accessible rolls (those with fewer than 4 neighbors) until no more can
  be removed. The answer is the total count of removed rolls.</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The Iterative Approach</h3>
  <div class="row">
  <div class="lhs">
  <p>This is a classic fixed-point iteration. Each round, we:</p>
  <ol type="1">
  <li>Identify accessible rolls (using our Part 1 logic)</li>
  <li>Remove them from the grid</li>
  <li>Repeat until the grid stops changing</li>
  </ol>
  <p>The trick: when we remove rolls, previously inaccessible rolls
  might become accessible (they now have fewer neighbors). So we keep
  iterating until we reach a stable state.</p>
  <p>The final answer is the difference between the original grid size
  and the final grid size.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb26"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> <span class="dt">Grid</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>solvePart2 grid <span class="ot">=</span> <span class="kw">let</span> finalGrid <span class="ot">=</span> removeAll grid</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">in</span> <span class="fu">length</span> grid <span class="op">-</span> <span class="fu">length</span> finalGrid</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Keep only inaccessible rolls (4+ neighbors)</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    removeOnce ::</span> <span class="dt">Grid</span> <span class="ot">-&gt;</span> <span class="dt">Grid</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    removeOnce grid <span class="ot">=</span> Set.filter (\pos <span class="ot">-&gt;</span> getAdjacentRolls grid pos <span class="op">&gt;=</span> <span class="dv">4</span>) grid</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Iterate until we reach a fixed point (grid stops changing)</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    removeAll ::</span> <span class="dt">Grid</span> <span class="ot">-&gt;</span> <span class="dt">Grid</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    removeAll grid <span class="ot">=</span> <span class="kw">let</span> <span class="op">!</span>next <span class="ot">=</span> removeOnce grid</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">in</span> <span class="kw">if</span> Set.size next <span class="op">==</span> Set.size grid</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">then</span> grid</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">else</span> removeAll next</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-5">Day 5</h1>
  <h2 id="part-1-4">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle gives us a database containing two pieces of
  information:</p>
  <ol type="1">
  <li>A list of valid ranges (e.g., <code>100-500</code>,
  <code>600-1000</code>)</li>
  <li>A list of ID numbers to check</li>
  </ol>
  <p>Our task for Part 1: count how many of the given IDs fall within at
  least one of the valid ranges. An ID is “fresh” if it’s covered by any
  range.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb27"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-name-shadowing #-}</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day05</span> <span class="kw">where</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sortBy)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> (on)</span></code></pre></div>
  </div>
  </div>
  <h3> Data Model</h3>
  <div class="row">
  <div class="lhs">
  <p>We’ll represent ranges as pairs of integers and bundle everything
  into a <code>Database</code> type for clean organization.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb28"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Range</span> <span class="ot">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Database</span> <span class="ot">=</span> <span class="dt">Database</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> ranges ::</span> [<span class="dt">Range</span>]</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> ids ::</span> [<span class="dt">Int</span>]</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
  </div>
  </div>
  <h3> Parsing</h3>
  <div class="row">
  <div class="lhs">
  <p>The input format has ranges first (one per line), then a blank
  line, then a list of IDs. We split on the blank line and parse each
  section accordingly.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb29"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Database</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>parse str <span class="ot">=</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> rows <span class="ot">=</span> <span class="fu">lines</span> str</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>      (rangeLines, idLines) <span class="ot">=</span> <span class="fu">break</span> (<span class="fu">null</span>) rows</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="dt">Database</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>        (<span class="fu">map</span> parseRange rangeLines)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        (<span class="fu">map</span> <span class="fu">read</span> <span class="op">$</span> <span class="fu">tail</span> idLines)</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseRange ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Range</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>  parseRange str <span class="ot">=</span> <span class="kw">let</span> (fst&#39;, snd&#39;) <span class="ot">=</span> <span class="fu">break</span> (<span class="op">==</span> <span class="ch">&#39;-&#39;</span>) str</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">in</span> (<span class="fu">read</span> fst&#39;, <span class="fu">read</span> <span class="op">.</span> <span class="fu">tail</span> <span class="op">$</span> snd&#39;)</span></code></pre></div>
  </div>
  </div>
  <h3> The Solution</h3>
  <div class="row">
  <div class="lhs">
  <p>Part 1 is straightforward: for each ID, check if any range contains
  it. Count the IDs that pass this test.</p>
  <p>The <code>contains</code> helper checks if a value falls within a
  range’s bounds (inclusive).</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb30"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> <span class="dt">Database</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>solvePart1 (<span class="dt">Database</span> ranges ids) <span class="ot">=</span> <span class="fu">length</span> <span class="op">$</span> <span class="fu">filter</span> isFresh ids</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  isFresh ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  isFresh <span class="fu">id</span> <span class="ot">=</span> <span class="fu">any</span> (contains <span class="fu">id</span>) ranges</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  contains ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>  contains <span class="fu">id</span> (<span class="fu">min</span>, <span class="fu">max</span>) <span class="ot">=</span> <span class="fu">id</span> <span class="op">&gt;=</span> <span class="fu">min</span> <span class="op">&amp;&amp;</span> <span class="fu">id</span> <span class="op">&lt;=</span> <span class="fu">max</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-4">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 asks a different question: what’s the total count of unique
  integers covered by all the ranges combined?</p>
  <p>For example, if we have ranges <code>1-5</code> and
  <code>3-8</code>, the unique integers covered are
  <code>[1,2,3,4,5,6,7,8]</code>, giving us a count of 8 (not 11, which
  would be if we counted overlaps twice).</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The Sorting Insight</h3>
  <div class="row">
  <div class="lhs">
  <p>The key insight: if we sort the ranges by their start position, we
  know that each subsequent range never starts before any previous
  range. This makes merging overlaps much simpler.</p>
  <p>As we fold through the sorted ranges, we track: - The previous
  range’s maximum value - The running count of unique integers
  covered</p>
  <p>For each new range, we calculate how many <em>new</em> integers it
  contributes by ensuring we don’t double-count overlaps with the
  previous range.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb31"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> <span class="dt">Database</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>solvePart2 <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> foldl&#39; addRange empty <span class="op">.</span> sortBy (<span class="fu">compare</span> <span class="ot">`on`</span> <span class="fu">fst</span>) <span class="op">.</span> ranges</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  countRange (<span class="fu">min</span>, <span class="fu">max</span>) <span class="ot">=</span> <span class="fu">max</span> <span class="op">-</span> <span class="fu">min</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  addRange ::</span> (<span class="dt">Range</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> (<span class="dt">Range</span>, <span class="dt">Int</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>  addRange ((_, prevMax), count) (nextMin, nextMax) <span class="ot">=</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newRange <span class="ot">=</span> ( <span class="fu">max</span> nextMin (prevMax <span class="op">+</span> <span class="dv">1</span>), <span class="fu">max</span> nextMax prevMax)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (newRange, count <span class="op">+</span> countRange newRange)</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  empty ::</span> (<span class="dt">Range</span>, <span class="dt">Int</span>)</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>  empty <span class="ot">=</span> ((<span class="fu">undefined</span>, (<span class="op">-</span><span class="dv">2</span>)), <span class="dv">0</span>)</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-6">Day 6</h1>
  <h2 id="part-1-5">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle gives us a grid of numbers followed by a line of
  operations.</p>
  <p>The twist? We need to read the grid <strong>vertically</strong>
  (column by column) rather than horizontally. Each column of numbers
  gets paired with an operation from the last line, and we apply that
  operation to get a result. The final answer is the sum of all column
  results.</p>
  <p>For example, if a column is <code>[2, 3, 5]</code> and the
  operation is <code>+</code>, we get <code>10</code>. If the operation
  is <code>*</code>, we get <code>30</code>.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb32"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-name-shadowing #-}</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day06</span> <span class="kw">where</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (unsnoc, transpose)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span> (isSpace)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;))</span></code></pre></div>
  </div>
  </div>
  <h3> Part 1 Solution</h3>
  <div class="row">
  <div class="lhs">
  <p>The algorithm is straightforward:</p>
  <ol type="1">
  <li>Split the input into rows and the final operations line</li>
  <li>Parse each row as space-separated numbers</li>
  <li><strong>Transpose</strong> to get columns instead of rows</li>
  <li>Zip operations with columns and apply each operation</li>
  <li>Sum the results</li>
  </ol>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb33"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>part1 str <span class="ot">=</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="dt">Just</span> (rows, opsLine) <span class="ot">=</span> unsnoc <span class="op">.</span> <span class="fu">lines</span> <span class="op">$</span> str</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="ot">      matrix ::</span> [[<span class="dt">Int</span>]]</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>      matrix <span class="ot">=</span> transpose <span class="op">.</span> <span class="fu">map</span> (<span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span>) <span class="op">.</span> <span class="fu">words</span>) <span class="op">$</span> rows</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>      ops <span class="ot">=</span> <span class="fu">words</span> opsLine</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> (<span class="fu">uncurry</span> getOp) <span class="op">$</span> <span class="fu">zip</span> ops matrix</span></code></pre></div>
  </div>
  </div>
  <h3> Operations</h3>
  <div class="row">
  <div class="lhs">
  <p>We support two operations: sum (<code>+</code>) and product
  (<code>*</code>).</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb34"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getOp ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>getOp <span class="st">&quot;+&quot;</span> <span class="ot">=</span> <span class="fu">sum</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>getOp <span class="st">&quot;*&quot;</span> <span class="ot">=</span> <span class="fu">product</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>getOp _ <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;unreachable&quot;</span></span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-5">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 changes the parsing rules. Now the grid can contain
  <strong>empty spaces</strong> within columns, and we need to treat
  sequences of numbers separated by spaces as distinct groups within
  each column.</p>
  <p>For example, a column might look like:</p>
  <pre><code>1
2

3
4</code></pre>
  <p>This represents two groups: <code>[1, 2]</code> and
  <code>[3, 4]</code>. We split on empty spaces, apply operations to
  each group separately, then sum everything.</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The Solution</h3>
  <div class="row">
  <div class="lhs">
  <p>The key difference is in how we process the transposed data:</p>
  <ol type="1">
  <li>Strip whitespace from each cell</li>
  <li>Split on empty strings to get groups</li>
  <li>Parse each group as numbers</li>
  <li>Apply operations as before</li>
  </ol>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb36"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>part2 str <span class="ot">=</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="dt">Just</span> (rows, opsLine) <span class="ot">=</span> unsnoc <span class="op">.</span> <span class="fu">lines</span> <span class="op">$</span> str</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>      numbers <span class="ot">=</span> rows</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>             <span class="op">&amp;</span> transpose</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>             <span class="op">&amp;</span> <span class="fu">map</span> (strip)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>             <span class="op">&amp;</span> splitOn <span class="fu">null</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>             <span class="op">&amp;</span> <span class="fu">map</span> (<span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span>))</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>      ops <span class="ot">=</span> <span class="fu">words</span> opsLine</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> (<span class="fu">uncurry</span> getOp) <span class="op">$</span> <span class="fu">zip</span> ops numbers</span></code></pre></div>
  </div>
  </div>
  <h3> Helper Functions</h3>
  <div class="row">
  <div class="lhs">
  <p>We need helpers to strip whitespace and split on a predicate.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb37"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ot">strip ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>strip <span class="ot">=</span> <span class="fu">dropWhile</span> (<span class="fu">isSpace</span>) <span class="op">&gt;&gt;&gt;</span> <span class="fu">takeWhile</span> (<span class="fu">not</span> <span class="op">.</span> <span class="fu">isSpace</span>)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="ot">splitOn ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>splitOn _ [] <span class="ot">=</span> []</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>splitOn fn xs <span class="ot">=</span> <span class="kw">let</span> (<span class="fu">group</span>, rest) <span class="ot">=</span> <span class="fu">break</span> fn xs</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>                    remaining <span class="ot">=</span> splitOn fn (<span class="fu">drop</span> <span class="dv">1</span> rest)</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span> <span class="kw">if</span> <span class="fu">null</span> <span class="fu">group</span> <span class="kw">then</span> remaining <span class="kw">else</span> <span class="fu">group</span> <span class="op">:</span> remaining</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-7">Day 7</h1>
  <h2 id="part-1-6">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle involves a beam of light traveling through a grid
  containing tachyons (represented by <code>^</code> symbols). The beam
  starts at position <code>S</code> and travels upward through
  columns.</p>
  <p>When the beam hits a tachyon, something interesting happens: it
  <strong>splits</strong> into two beams that move horizontally (one
  left, one right), then continue upward from their new positions.</p>
  <p>Our task: count how many unique tachyons the beam(s) will hit.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb38"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-name-shadowing #-}</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day07</span> <span class="kw">where</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;), on)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (find, sortBy, sort, uncons)</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashMap.Lazy</span> (<span class="dt">HashMap</span>, (!?))</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.HashMap.Lazy</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.HashSet</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashSet</span> (<span class="dt">HashSet</span>)</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (guard)</span></code></pre></div>
  </div>
  </div>
  <h3> Data Model</h3>
  <div class="row">
  <div class="lhs">
  <p>We need to track:</p>
  <ul>
  <li>Where the beam starts (<code>S</code> position)</li>
  <li>Where all the tachyons are (organized by column for efficient
  lookup)</li>
  </ul>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb39"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Instructions</span> <span class="ot">=</span> <span class="dt">Instructions</span> {</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  _start ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>),</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  _tachyons ::</span> <span class="dt">HashMap</span> <span class="dt">Int</span> [<span class="dt">Int</span>]  <span class="co">-- maps column x to list of y coordinates</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>} <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
  </div>
  </div>
  <h3> Parsing</h3>
  <div class="row">
  <div class="lhs">
  <p>We scan the grid for special characters: <code>S</code> marks the
  start position, and <code>^</code> marks tachyons. We organize
  tachyons by column and sort their y-coordinates for efficient upward
  traversal.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb40"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Instructions</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>parse str <span class="ot">=</span> <span class="kw">let</span><span class="ot"> chars ::</span> [(<span class="dt">Char</span>, (<span class="dt">Int</span>, <span class="dt">Int</span>))]</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>                chars <span class="ot">=</span> [ (c, (x, y))</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>                        <span class="op">|</span> (y, line) <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] (<span class="fu">lines</span> str)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>                        , (x, c)    <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] line</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>                        , c <span class="op">/=</span> <span class="ch">&#39;.&#39;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>                        ]</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Just</span> (_, start) <span class="ot">=</span> find (\(c, _) <span class="ot">-&gt;</span> c <span class="op">==</span> <span class="ch">&#39;S&#39;</span>) chars</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>                tachyons <span class="ot">=</span> chars</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;</span> <span class="fu">filter</span> (\(c, _) <span class="ot">-&gt;</span> c <span class="op">==</span> <span class="ch">&#39;^&#39;</span>)</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;</span> <span class="fu">map</span> <span class="fu">snd</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;</span> sortBy (<span class="fu">compare</span> <span class="ot">`on`</span> <span class="fu">fst</span>)</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;</span> groupBy <span class="fu">fst</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;</span> <span class="fu">map</span> (\col <span class="ot">-&gt;</span> (<span class="fu">fst</span> <span class="op">$</span> <span class="fu">head</span> col, <span class="fu">map</span> <span class="fu">snd</span> col))</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;</span> Map.fromList</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;</span> <span class="fu">fmap</span> (<span class="fu">sort</span>)</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>             <span class="kw">in</span> <span class="dt">Instructions</span> start tachyons</span></code></pre></div>
  </div>
  </div>
  <h3> Helper: Grouping</h3>
  <div class="row">
  <div class="lhs">
  <p>A simple grouping function that clusters consecutive elements with
  the same key.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb41"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">groupBy ::</span> (<span class="dt">Eq</span> b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>groupBy fn [] <span class="ot">=</span> []</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>groupBy fn (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="kw">let</span> (<span class="fu">group</span>, rest) <span class="ot">=</span> <span class="fu">span</span> (\a <span class="ot">-&gt;</span> fn a <span class="op">==</span> fn x) xs</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">in</span> (x<span class="op">:</span><span class="fu">group</span>) <span class="op">:</span> groupBy fn rest</span></code></pre></div>
  </div>
  </div>
  <h3> The Algorithm</h3>
  <div class="row">
  <div class="lhs">
  <p>The beam simulation is a recursive traversal:</p>
  <ol type="1">
  <li>From the current position <code>(x, y)</code>, look up the column
  and find the next tachyon above the current y-coordinate</li>
  <li>If we find one and haven’t visited it yet:
  <ul>
  <li>Mark it as visited</li>
  <li>Remove it from the available tachyons</li>
  <li>Split: recursively simulate beams going left
  <code>(x-1, newY)</code> and right <code>(x+1, newY)</code></li>
  </ul></li>
  <li>If no tachyon found or already visited, return the current visited
  set</li>
  </ol>
  <p>The union of all visited tachyons gives us the answer.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb42"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> <span class="dt">Instructions</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>solvePart1 (<span class="dt">Instructions</span> start tachyons) <span class="ot">=</span> Set.size <span class="op">$</span> go <span class="fu">mempty</span> start tachyons</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">HashSet</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">HashMap</span> <span class="dt">Int</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">HashSet</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    go cache (x, y) tachyons <span class="ot">=</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> match <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>            col <span class="ot">&lt;-</span> tachyons <span class="op">!?</span> x</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>            (<span class="fu">head</span>, rest) <span class="ot">&lt;-</span> uncons <span class="op">$</span> <span class="fu">dropWhile</span> (<span class="op">&lt;</span> y) col</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>            guard <span class="op">$</span> <span class="fu">not</span> <span class="op">$</span> (x, <span class="fu">head</span>) <span class="ot">`Set.member `</span> cache</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> newMap <span class="ot">=</span> Map.insert x rest tachyons</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> (<span class="fu">head</span>, newMap)</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> <span class="kw">case</span> match <span class="kw">of</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> (newY, newMap) <span class="ot">-&gt;</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span> newCache <span class="ot">=</span> Set.insert (x, newY) cache</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>                  lhs <span class="ot">=</span> go newCache (x <span class="op">-</span> <span class="dv">1</span>, newY) newMap</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>                  rhs <span class="ot">=</span> go lhs (x <span class="op">+</span> <span class="dv">1</span>, newY) newMap</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>               <span class="kw">in</span> Set.union lhs rhs</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> cache</span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-6">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 asks: how many distinct <strong>paths</strong> does the beam
  take to reach the end?</p>
  <p>Instead of just counting visited tachyons, we now count all the
  different ways the beam can split and travel through the grid. This is
  a classic path-counting problem that benefits from
  <strong>memoization</strong>—if we reach the same tachyon from the
  same direction multiple times, the number of paths from there is
  always the same.</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The Memoized Solution</h3>
  <div class="row">
  <div class="lhs">
  <p>The algorithm is similar to Part 1, but now:</p>
  <ul>
  <li>We track a cache of <code>(position -&gt; path_count)</code>
  instead of a set</li>
  <li>When we reach a position we’ve seen before, return the cached
  count</li>
  <li>When we reach the end (no more tachyons), that’s 1 complete
  path</li>
  <li>The total count is the sum of paths going left and right at each
  split</li>
  </ul>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb43"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> <span class="dt">Instructions</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>solvePart2 (<span class="dt">Instructions</span> start tachyons) <span class="ot">=</span> <span class="fu">snd</span> <span class="op">$</span> go <span class="fu">mempty</span> start tachyons</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">HashMap</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">HashMap</span> <span class="dt">Int</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> (<span class="dt">HashMap</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    go cache (x, y) tachyons <span class="ot">=</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> match <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>            col <span class="ot">&lt;-</span> tachyons <span class="op">!?</span> x</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>            (<span class="fu">head</span>, rest) <span class="ot">&lt;-</span> uncons <span class="op">$</span> <span class="fu">dropWhile</span> (<span class="op">&lt;</span> y) col</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> newMap <span class="ot">=</span> Map.insert x rest tachyons</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> (<span class="fu">head</span>, newMap, cache <span class="op">Map.!?</span> (x, <span class="fu">head</span>))</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> <span class="kw">case</span> match <span class="kw">of</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> (newY, newMap, count) <span class="ot">-&gt;</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>              <span class="kw">case</span> count <span class="kw">of</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Just</span> n <span class="ot">-&gt;</span> (cache, n)  <span class="co">-- Cache hit!</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">let</span> (leftCache, nl) <span class="ot">=</span> go cache (x <span class="op">-</span> <span class="dv">1</span>, newY) newMap</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>                               (rightCache, nr) <span class="ot">=</span> go leftCache (x <span class="op">+</span> <span class="dv">1</span>, newY) newMap</span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>                               newCache <span class="ot">=</span> Map.insert (x, newY) (nl <span class="op">+</span> nr) <span class="op">$</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>                                 Map.union leftCache rightCache</span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>                           <span class="kw">in</span> (newCache, nl <span class="op">+</span> nr)</span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> (Map.empty, <span class="dv">1</span>)  <span class="co">-- Reached the end, count as 1 path</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-8">Day 8</h1>
  <h2 id="part-1-7">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle gives us electrical junctions floating in 3D space,
  each described by x,y,z coordinates:</p>
  <div class="sourceCode" id="cb44"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>162,817,812</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>57,618,57</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>906,360,560</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>...</span></code></pre></div>
  <p>Our task: repeatedly pick the two closest junctions and connect
  them into a circuit. This happens 1000 times, and each connection can
  play out in three ways:</p>
  <ul>
  <li><strong>Both unconnected</strong>: Create a new circuit containing
  both junctions</li>
  <li><strong>One connected</strong>: Add the unconnected junction to
  the existing circuit</li>
  <li><strong>Both connected</strong>: Merge their two circuits into
  one</li>
  </ul>
  <p>After 1000 connections, we multiply the sizes of the three largest
  circuits together.</p>
  <p>If this sounds like a job for a <strong>Union-Find (Disjoint
  Set)</strong> data structure, you’re absolutely right. That’s the
  textbook efficient solution for this kind of problem.</p>
  <p>Here’s the thing: this puzzle is actually <em>why</em> I learned
  about disjoint sets in the first place—but only <em>after</em> I’d
  already solved it my own way. So today we’ll walk through my original,
  more naive approach using the State monad and some good old
  hashmaps.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb45"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-name-shadowing #-}</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day08</span> <span class="kw">where</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Linear.V3</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> (on)</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.Split</span> (splitOn)</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span> (readFile&#39;)</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sortBy)</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashMap.Strict</span> (<span class="dt">HashMap</span>, (!?) )</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.HashMap.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Lens</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State.Lazy</span> (<span class="dt">State</span>, evalState)</span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM_)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Let’s start with our data model. We’ll use integers to identify
  circuits and 3D vectors from the <code>linear</code> library to
  represent junction positions.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb46"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CircuitId</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Junction</span> <span class="ot">=</span> (<span class="dt">V3</span> <span class="dt">Int</span>)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Parsing is straightforward—each line contains comma-separated x,y,z
  coordinates.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb47"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Junction</span>]</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">map</span> parseJunction <span class="op">.</span> <span class="fu">lines</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseJunction ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Junction</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  parseJunction line <span class="ot">=</span> <span class="kw">let</span> [x, y, z] <span class="ot">=</span> splitOn <span class="st">&quot;,&quot;</span> line</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">in</span> <span class="dt">V3</span> (<span class="fu">read</span> x) (<span class="fu">read</span> y) (<span class="fu">read</span> z)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>For distance calculations, we use squared Euclidean distance. Since
  we only care about relative distances for sorting, we can skip the
  <code>sqrt</code>—it’s monotonic, so the ordering stays the same and
  we save some computation.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb48"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="ot">distanceTo ::</span> <span class="dt">Junction</span> <span class="ot">-&gt;</span> <span class="dt">Junction</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>distanceTo (<span class="dt">V3</span> x1 y1 z1) (<span class="dt">V3</span> x2 y2 z2) <span class="ot">=</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>         (<span class="fu">fromIntegral</span> (x2 <span class="op">-</span> x1)) <span class="op">**</span> <span class="fl">2.0</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>       <span class="op">+</span> (<span class="fu">fromIntegral</span> (y2 <span class="op">-</span> y1)) <span class="op">**</span> <span class="fl">2.0</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>       <span class="op">+</span> (<span class="fu">fromIntegral</span> (z2 <span class="op">-</span> z1)) <span class="op">**</span> <span class="fl">2.0</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The <code>distances</code> function generates all possible junction
  pairs and sorts them by distance, giving us a priority queue of
  connections to process.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb49"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">distances ::</span> [<span class="dt">Junction</span>] <span class="ot">-&gt;</span> [(<span class="dt">Junction</span>, <span class="dt">Junction</span>)]</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>distances vecs <span class="ot">=</span> [ (v1, v2)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>                 <span class="op">|</span> (ix, v1) <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] vecs</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>                 , v2 <span class="ot">&lt;-</span> <span class="fu">drop</span> (ix <span class="op">+</span> <span class="dv">1</span>) vecs</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>                 ] <span class="op">&amp;</span> sortBy (<span class="fu">compare</span> <span class="ot">`on`</span> <span class="fu">uncurry</span> distanceTo)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Now for the core state management. Our <code>ProblemState</code>
  tracks three things:</p>
  <ul>
  <li><strong><code>nextCircuitId</code></strong>: Counter for assigning
  IDs to new circuits</li>
  <li><strong><code>junctions</code></strong>: Maps each junction to its
  circuit ID (for fast “which circuit am I in?” lookups)</li>
  <li><strong><code>circuits</code></strong>: Maps each circuit ID to
  its junctions (for fast “what’s in this circuit?” lookups)</li>
  </ul>
  <p>This bidirectional indexing lets us efficiently handle all three
  connection cases.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb50"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ProblemState</span> <span class="ot">=</span> <span class="dt">ProblemState</span> {</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  _nextCircuitId ::</span> <span class="dt">CircuitId</span>,</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  _junctions ::</span> <span class="dt">HashMap</span> <span class="dt">Junction</span> <span class="dt">CircuitId</span>,</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  _circuits ::</span> <span class="dt">HashMap</span> <span class="dt">CircuitId</span> [<span class="dt">Junction</span>]</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="ot">emptyState ::</span> <span class="dt">ProblemState</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>emptyState <span class="ot">=</span> <span class="dt">ProblemState</span> <span class="dv">0</span> Map.empty Map.empty</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>We’re using the <strong>State monad</strong> combined with the
  <strong>lens library</strong> to keep our solution clean and readable.
  Lenses let us update nested state elegantly without the usual record
  update boilerplate. If you’re new to lenses, I highly recommend <a
  href="https://leanpub.com/optics-by-example/">Optics By
  Example</a>.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb51"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>makeLenses <span class="dt">&#39;ProblemState</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>We alias our computation type as <code>Solver</code> for
  clarity.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb52"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Solver</span> a <span class="ot">=</span> <span class="dt">State</span> <span class="dt">ProblemState</span> a</span></code></pre></div>
  </div>
  </div>
  <h3> Building blocks</h3>
  <div class="row">
  <div class="lhs">
  <p>Adding a junction to a circuit requires updating both indexes: we
  record which circuit the junction belongs to, and add the junction to
  that circuit’s member list.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb53"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addJunctionToCircuit ::</span> (<span class="dt">V3</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">CircuitId</span> <span class="ot">-&gt;</span> <span class="dt">Solver</span> ()</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>addJunctionToCircuit junction circuitId <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    junctions <span class="op">%=</span> Map.insert junction circuitId</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    circuits <span class="op">%=</span> Map.alter (insert junction) circuitId</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> ()</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    insert ::</span> <span class="dt">V3</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">V3</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">V3</span> <span class="dt">Int</span>]</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>    insert junction <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Just</span> [junction]</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    insert junction (<span class="dt">Just</span> js) <span class="ot">=</span> <span class="dt">Just</span> (junction <span class="op">:</span> js)</span></code></pre></div>
  </div>
  </div>
  <h3> The core algorithm</h3>
  <div class="row">
  <div class="lhs">
  <p>Now for the heart of the solution: processing a junction pair.
  Given junctions <code>(a, b)</code>, we need to handle five distinct
  cases:</p>
  <ol type="1">
  <li><strong>Only <code>a</code> is connected</strong>: Add
  <code>b</code> to <code>a</code>’s circuit</li>
  <li><strong>Only <code>b</code> is connected</strong>: Add
  <code>a</code> to <code>b</code>’s circuit</li>
  <li><strong>Both in same circuit</strong>: Nothing to do</li>
  <li><strong>Both in different circuits</strong>: Merge them by moving
  all junctions from one circuit to the other, then delete the empty
  circuit</li>
  <li><strong>Neither connected</strong>: Create a new circuit
  containing both and increment our ID counter</li>
  </ol>
  <p>This is where things get interesting—and where a proper Union-Find
  structure would shine. But our State monad approach keeps the logic
  explicit and easy to follow.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb54"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addJunctionPair ::</span> (<span class="dt">V3</span> <span class="dt">Int</span>, <span class="dt">V3</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Solver</span> ()</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>addJunctionPair (a, b) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- find the circuits where a and b belong</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  mCa <span class="ot">&lt;-</span> uses junctions (<span class="op">!?</span> a)</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>  mCb <span class="ot">&lt;-</span> uses junctions (<span class="op">!?</span> b)</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> (mCa, mCb) <span class="kw">of</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Just</span> ca, <span class="dt">Nothing</span>) <span class="ot">-&gt;</span> addJunctionToCircuit b ca</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Nothing</span>, <span class="dt">Just</span> cb) <span class="ot">-&gt;</span> addJunctionToCircuit a cb</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Just</span> ca, <span class="dt">Just</span> cb) <span class="op">|</span> ca <span class="op">==</span> cb <span class="ot">-&gt;</span> <span class="fu">return</span> ()</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Just</span> ca, <span class="dt">Just</span> cb) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>      junctionsInCa <span class="ot">&lt;-</span> uses circuits (<span class="op">Map.!</span> ca)</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>      forM_ junctionsInCa <span class="op">$</span> <span class="fu">flip</span> addJunctionToCircuit cb</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>      circuits <span class="op">%=</span> Map.delete ca</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Nothing</span>, <span class="dt">Nothing</span>) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>      nextId <span class="ot">&lt;-</span> use nextCircuitId </span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>      nextCircuitId <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>      addJunctionToCircuit a nextId</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>      addJunctionToCircuit b nextId</span></code></pre></div>
  </div>
  </div>
  <h3> Putting it together</h3>
  <div class="row">
  <div class="lhs">
  <p>With our machinery in place, Part 1 is straightforward:</p>
  <ol type="1">
  <li>Take the 1000 closest junction pairs</li>
  <li>Process each pair with our state-modifying function</li>
  <li>Find the three largest circuits and multiply their sizes</li>
  </ol>
  <p>That final one-liner does some heavy lifting: it extracts all
  circuits, maps to their sizes, sorts in descending order, takes the
  top 3, and multiplies them together.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb55"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> [<span class="dt">V3</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>solvePart1 junctions <span class="ot">=</span> <span class="fu">flip</span> evalState emptyState <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pairs <span class="ot">=</span> <span class="fu">take</span> <span class="dv">1000</span> <span class="op">$</span> distances junctions</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>  forM_ pairs addJunctionPair</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>  uses circuits (Map.toList <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">length</span> <span class="op">.</span> <span class="fu">snd</span>) <span class="op">&gt;&gt;&gt;</span> sortBy (<span class="fu">flip</span> <span class="fu">compare</span>) <span class="op">&gt;&gt;&gt;</span> <span class="fu">take</span> <span class="dv">3</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">product</span>)</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-7">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 asks a different question: <em>when</em> do all junctions
  get connected into a single unified circuit? We need to find the
  specific pair that completes this unification, then multiply their
  x-coordinates together.</p>
  <p>The beautiful part? We’ve already built everything we need. Our
  state tracks both the number of junctions assigned to circuits and the
  number of distinct circuits. When those numbers are equal to the total
  junction count and 1 respectively, we’re done.</p>
  <p>The <code>addUntilDone</code> helper processes pairs one by one
  until it hits that condition, then returns the winning pair. Multiply
  the x-coordinates, and we have our answer.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb56"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> [<span class="dt">V3</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>solvePart2 js <span class="ot">=</span> <span class="fu">flip</span> evalState emptyState <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pairs <span class="ot">=</span> distances js</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>      addUntilDone [] <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;unreachable&quot;</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>      addUntilDone (n<span class="op">:</span>rest) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>        addJunctionPair n</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>        junctionCount <span class="ot">&lt;-</span> uses junctions Map.size</span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>        circuitCount <span class="ot">&lt;-</span> uses circuits Map.size</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> junctionCount <span class="op">==</span> <span class="fu">length</span> js <span class="op">&amp;&amp;</span> circuitCount <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>          <span class="kw">then</span> <span class="fu">return</span> n</span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> addUntilDone rest</span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a>  (a, b) <span class="ot">&lt;-</span> addUntilDone pairs</span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> a<span class="op">^.</span>_x <span class="op">*</span> b<span class="op">^.</span>_x</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-9">Day 9</h1>
  <h2 id="part-1-8">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle gives us a collection of points scattered across a
  2D grid. Our task: find the largest rectangle we can form by choosing
  any two points as opposite corners.</p>
  <p>The twist? The rectangle’s sides must be axis-aligned (parallel to
  the x and y axes), and we count tiles inclusively—so a rectangle from
  (0,0) to (2,2) contains 9 tiles, not 4.</p>
  <p>Oooof, these imports are getting out of hand! But hey, we’ve got
  SVG rendering to do later.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb57"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-incomplete-patterns #-}</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day09</span> <span class="kw">where</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Linear.V2</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.Split</span> (splitOn)</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span> (readFile&#39;)</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;))</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Lens.Getter</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Blaze.Svg11</span> ((!), m)</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Blaze.Svg11</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Blaze.Svg11.Attributes</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Blaze.Svg.Renderer.String</span> (renderSvg)</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Printf</span> (printf)</span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.String</span> (<span class="dt">IsString</span>(fromString))</span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Blaze.Svg</span> (mkPath)</span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM_)</span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Blaze.Svg11</span> (l)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The <code>linear</code> library’s <code>V2 Int</code> type is
  perfect for 2D points—it gives us vector operations for free if we
  need them later.</p>
  <p>Parsing is straightforward: each line contains comma-separated x,y
  coordinates.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb58"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Point</span> <span class="ot">=</span> <span class="dt">V2</span> <span class="dt">Int</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Point</span>]</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">lines</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> parseV2</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>  parseV2 line <span class="ot">=</span> <span class="kw">let</span> [x, y] <span class="ot">=</span> splitOn <span class="st">&quot;,&quot;</span> line</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>             <span class="kw">in</span> <span class="dt">V2</span> (<span class="fu">read</span> x) (<span class="fu">read</span> y)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>With a modest number of points, brute force is our friend. We check
  every possible pair of points, calculate the resulting rectangle’s
  area, and take the maximum.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb59"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> [<span class="dt">V2</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>solvePart1 tiles <span class="ot">=</span> </span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">maximum</span> [ area p1 p2 </span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> (ix, p1) <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">1</span><span class="op">..</span>] tiles</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>          , p2 <span class="ot">&lt;-</span> <span class="fu">drop</span> ix tiles </span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>          ]</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The <code>area</code> function adds 1 to each dimension because
  we’re counting tiles inclusively—a rectangle from (0,0) to (2,2) spans
  3 units in each direction, giving us 3×3=9 tiles.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb60"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="ot">area ::</span> <span class="dt">V2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">V2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>area (<span class="dt">V2</span> x1 y1) (<span class="dt">V2</span> x2 y2) <span class="ot">=</span> (<span class="fu">abs</span> (y2 <span class="op">-</span> y1) <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> (<span class="fu">abs</span> (x2 <span class="op">-</span> x1) <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-8">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 cranks up the difficulty: now we need to find the largest
  rectangle that fits <em>inside</em> a polygon formed by connecting all
  the input points in sequence.</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> A stroke of luck</h3>
  <div class="row">
  <div class="lhs">
  <p>My first instinct was to implement the classic <a
  href="https://en.wikipedia.org/wiki/Point_in_polygon">raycast</a>
  algorithm for point-in-polygon testing. But that’s a lot of code for
  something I’ve written before, and—let’s be honest—it’s not that
  interesting the second time around.</p>
  <p>Instead, I got curious. What does the actual input look like? I
  whipped up a quick SVG visualization:</p>
  <figure>
  <img src="day09-input.svg" alt="day09 input svg" />
  <figcaption aria-hidden="true">day09 input svg</figcaption>
  </figure>
  <p><strong>Jackpot!</strong> The polygon is roughly circular with a
  narrow cut extending inward from the edge.</p>
  <p>This observation unlocks a much simpler approach: any rectangle
  large enough to be worth considering will be entirely on one side of
  that cut. It either fits in the “upper” region or the “lower”
  region—it can’t bridge across the cut without intersecting an
  edge.</p>
  <p>So instead of checking if every point inside a candidate rectangle
  is within the polygon, we just need to verify that the rectangle’s
  boundary doesn’t intersect any polygon edges.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb61"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="ot">drawInput ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>drawInput <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>  points <span class="ot">&lt;-</span> parse <span class="op">&lt;$&gt;</span> readFile&#39; <span class="st">&quot;assets/day09-input.txt&quot;</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> edges <span class="ot">=</span> <span class="kw">let</span> (p<span class="op">:</span>ps) <span class="ot">=</span> points <span class="kw">in</span> <span class="fu">zip</span> (p<span class="op">:</span>ps) (ps <span class="op">++</span> [p])</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>      maxX <span class="ot">=</span> points <span class="op">&amp;</span> <span class="fu">map</span> (view _x) <span class="op">&amp;</span> <span class="fu">maximum</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>      maxY <span class="ot">=</span> points <span class="op">&amp;</span> <span class="fu">map</span> (view _y) <span class="op">&amp;</span> <span class="fu">maximum</span> </span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>      svgPath <span class="ot">=</span> mkPath <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>        forM_ edges <span class="op">$</span> \(e1, e2) <span class="ot">-&gt;</span> <span class="kw">do</span> </span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>          m (e1<span class="op">^.</span>_x) (e1<span class="op">^.</span>_y)</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>          l (e2<span class="op">^.</span>_x) (e2<span class="op">^.</span>_y)</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>      svg <span class="ot">=</span> renderSvg <span class="op">$</span> S.docTypeSvg <span class="op">!</span> A.version <span class="st">&quot;1.1&quot;</span> <span class="op">!</span> A.width <span class="st">&quot;400&quot;</span> <span class="op">!</span> A.height <span class="st">&quot;400&quot;</span> <span class="op">!</span> A.viewbox (fromString <span class="op">$</span> printf <span class="st">&quot;0 0 %d %d&quot;</span> maxX maxY) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>        S.path <span class="op">!</span> A.d svgPath <span class="op">!</span> A.strokeWidth <span class="st">&quot;400&quot;</span> <span class="op">!</span> A.stroke <span class="st">&quot;red&quot;</span>;</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> svg</span></code></pre></div>
  </div>
  </div>
  <h3> The solution</h3>
  <div class="row">
  <div class="lhs">
  <p>Armed with our insight, the solution mirrors Part 1’s brute
  force—except now we filter out any rectangle whose interior intersects
  with a polygon edge.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb62"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> [<span class="dt">V2</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>solvePart2 squares<span class="op">@</span>(p<span class="op">:</span>ps) <span class="ot">=</span> </span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> rectangles <span class="ot">=</span> [ (p1, p2)</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>                    <span class="op">|</span> (ix, p1) <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">1</span><span class="op">..</span>] squares</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>                    , p2 <span class="ot">&lt;-</span> <span class="fu">drop</span> ix squares</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>                    , <span class="fu">not</span> (intersects p1 p2 edges)</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>                    ]</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>       edges <span class="ot">=</span> <span class="fu">zip</span> (p<span class="op">:</span>ps) (ps <span class="op">++</span> [p])</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="fu">maximum</span> <span class="op">$</span> <span class="fu">map</span> (<span class="fu">uncurry</span> area) <span class="op">$</span> rectangles</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The <code>intersects</code> function checks if any polygon edge
  crosses through our candidate rectangle. We do this by testing whether
  the edge’s bounding box overlaps with the rectangle’s interior. If any
  edge overlaps, the rectangle is invalid.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb63"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="ot">intersects ::</span> <span class="dt">V2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">V2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [(<span class="dt">V2</span> <span class="dt">Int</span>, <span class="dt">V2</span> <span class="dt">Int</span>)] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>intersects p1 p2 edges <span class="ot">=</span> <span class="fu">any</span> inside <span class="op">$</span> edges</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    inside ::</span> (<span class="dt">V2</span> <span class="dt">Int</span>, <span class="dt">V2</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    inside (e1, e2) <span class="ot">=</span> <span class="fu">min</span> (e1<span class="op">^.</span>_x) (e2<span class="op">^.</span>_x) <span class="op">&lt;</span> maxX </span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>                     <span class="op">&amp;&amp;</span> <span class="fu">max</span> (e1<span class="op">^.</span>_x) (e2<span class="op">^.</span>_x) <span class="op">&gt;</span> minX </span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>                     <span class="op">&amp;&amp;</span> <span class="fu">min</span> (e1<span class="op">^.</span>_y) (e2<span class="op">^.</span>_y) <span class="op">&lt;</span> maxY </span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>                     <span class="op">&amp;&amp;</span> <span class="fu">max</span> (e1<span class="op">^.</span>_y) (e2<span class="op">^.</span>_y) <span class="op">&gt;</span> minY </span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>    minX <span class="ot">=</span> <span class="fu">min</span> (p1<span class="op">^.</span>_x) (p2<span class="op">^.</span>_x)</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>    maxX <span class="ot">=</span> <span class="fu">max</span> (p1<span class="op">^.</span>_x) (p2<span class="op">^.</span>_x)</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>    minY <span class="ot">=</span> <span class="fu">min</span> (p1<span class="op">^.</span>_y) (p2<span class="op">^.</span>_y)</span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>    maxY <span class="ot">=</span> <span class="fu">max</span> (p1<span class="op">^.</span>_y) (p2<span class="op">^.</span>_y)</span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-10">Day 10</h1>
  <h2 id="part-1-9">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle presents us with a collection of lights, each
  composed of multiple LEDs. Our task: figure out the minimum number of
  button presses needed to configure each light to match a target
  pattern.</p>
  <p>Each light comes with three pieces of information:</p>
  <ul>
  <li><strong>Target configuration</strong>: a string like
  <code>[.##.]</code> where <code>#</code> represents an LED that should
  be ON and <code>.</code> represents one that should be OFF</li>
  <li><strong>Buttons</strong>: each button, when pressed, toggles
  specific LEDs (e.g., <code>(1,3)</code> toggles LEDs at indices 1 and
  3)</li>
  <li><strong>Joltages</strong>: power requirements we can safely ignore
  for Part 1</li>
  </ul>
  <p>For example, in
  <code>[.##.] (3) (1,3) (2) (2,3) (0,2) (0,1) {3,5,4,7}</code>: - We
  want LEDs at positions 1 and 2 to be ON, the rest OFF - We have six
  buttons available, each toggling different LED combinations - The
  joltages <code>{3,5,4,7}</code> don’t matter yet</p>
  <p>This is essentially a search problem: starting from all LEDs off,
  find the shortest sequence of button presses to reach the target
  configuration</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb64"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day10</span> <span class="kw">where</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (uncons)</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;))</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Bits</span> ((.&lt;&lt;.), (.|.))</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.Split</span> (splitOn)</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span> (readFile&#39;)</span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.HashMap.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashMap.Strict</span> (<span class="dt">HashMap</span>)</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.IntSet</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.IntSet</span> (<span class="dt">IntSet</span>)</span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Debug.Trace</span> (traceShowId)</span></code></pre></div>
  </div>
  </div>
  <h3> Modeling the problem</h3>
  <div class="row">
  <div class="lhs">
  <p>We’ll represent each light with a simple record type. The key
  insight is that we only care about <em>which</em> LEDs are on, not
  their order, so <code>IntSet</code> is perfect for tracking
  configurations efficiently.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb65"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Light</span> <span class="ot">=</span> <span class="dt">Light</span> {</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  _target ::</span> <span class="dt">IntSet</span>,</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  _buttons ::</span> [[<span class="dt">Int</span>]],</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  _joltages ::</span> [<span class="dt">Int</span>]</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>} <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Parsing this format is a bit fiddly—we need to strip brackets,
  parentheses, and curly braces, then split on commas and whitespace.
  Not the most elegant code I’ve written, but it gets the job done
  without pulling in heavy parsing libraries.</p>
  <p><strong>Reminder to Self</strong>: find better combinators for
  parsing. (Although I’d like to keep my solutions parsec and regex
  free)</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb66"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Light</span>]</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">map</span> (parseLine <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseLine ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Light</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>  parseLine <span class="fu">words</span> <span class="ot">=</span> </span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="dt">Just</span> (light, rest) <span class="ot">=</span> uncons <span class="fu">words</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>        (buttons, [joltages]) <span class="ot">=</span> <span class="fu">break</span> ((<span class="op">==</span> <span class="ch">&#39;{&#39;</span>) <span class="op">.</span> <span class="fu">head</span>) rest</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> <span class="dt">Light</span> (parseLight light) (<span class="fu">map</span> parseButton buttons) (parseJoltages joltages)</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseLight ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IntSet</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>  parseLight str <span class="ot">=</span> <span class="fu">filter</span> (\c <span class="ot">-&gt;</span> c <span class="op">/=</span> <span class="ch">&#39;[&#39;</span> <span class="op">&amp;&amp;</span> c <span class="op">/=</span> <span class="ch">&#39;]&#39;</span>) str</span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&amp;</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>]</span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&amp;</span> <span class="fu">filter</span> ((<span class="op">==</span> <span class="ch">&#39;#&#39;</span>) <span class="op">.</span> <span class="fu">snd</span>)</span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&amp;</span> <span class="fu">map</span> (<span class="fu">fst</span>)</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&amp;</span> Set.fromList</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseButton ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>  parseButton <span class="ot">=</span> <span class="fu">filter</span> (\c <span class="ot">-&gt;</span> c <span class="op">/=</span> <span class="ch">&#39;(&#39;</span> <span class="op">&amp;&amp;</span> c <span class="op">/=</span> <span class="ch">&#39;)&#39;</span>) </span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>              <span class="op">&gt;&gt;&gt;</span> splitOn <span class="st">&quot;,&quot;</span></span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>              <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span>)</span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseJoltages ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a>  parseJoltages <span class="ot">=</span> <span class="fu">filter</span> (\c <span class="ot">-&gt;</span> c <span class="op">/=</span> <span class="ch">&#39;{&#39;</span> <span class="op">&amp;&amp;</span> c <span class="op">/=</span> <span class="ch">&#39;}&#39;</span>) <span class="op">&gt;&gt;&gt;</span> splitOn <span class="st">&quot;,&quot;</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span>)</span></code></pre></div>
  </div>
  </div>
  <h3> Finding the shortest path</h3>
  <div class="row">
  <div class="lhs">
  <p>When we want the <em>minimum</em> number of steps to reach a goal,
  breadth-first search (BFS) is our go-to algorithm. It explores all
  configurations reachable in N steps before trying any configuration
  that takes N+1 steps—guaranteeing we find the shortest path.</p>
  <p>Here’s the game plan: 1. Start with all LEDs off (empty
  <code>IntSet</code>) 2. For each configuration we’re exploring, try
  pressing every button 3. Track which configurations we’ve seen before
  to avoid cycles 4. Stop when we reach the target configuration</p>
  <p>The <code>breadth</code> function does the heavy lifting: -
  <code>states</code>: configurations we’re currently exploring -
  <code>cache</code>: a map recording how many steps it took to reach
  each configuration - <code>steps</code>: current depth in our
  search</p>
  <p>Each iteration generates new configurations by clicking every
  possible button on every current state, filters out ones we’ve seen
  before, and continues until we hit the target</p>
  <p>The helper functions are straightforward: <code>clickButton</code>
  applies a button press to a configuration by toggling each LED the
  button affects, and <code>toggleLight</code> flips a single LED on or
  off.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb67"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="ot">findMinButtonPresses ::</span> <span class="dt">Light</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>findMinButtonPresses (<span class="dt">Light</span> target buttons _) <span class="ot">=</span> </span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (cache, _) <span class="ot">=</span> breadth <span class="dv">0</span> (Map.singleton Set.empty <span class="dv">0</span>)[ Set.empty ]</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> cache <span class="op">Map.!</span> target</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  breadth ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">HashMap</span> <span class="dt">IntSet</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">IntSet</span>] <span class="ot">-&gt;</span> (<span class="dt">HashMap</span> <span class="dt">IntSet</span> <span class="dt">Int</span>, [<span class="dt">IntSet</span>])</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>  breadth steps cache states <span class="ot">=</span> </span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="op">!</span>b <span class="ot">=</span> <span class="fu">concatMap</span> (\s <span class="ot">-&gt;</span> </span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>              <span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> (<span class="fu">flip</span> Map.member cache)) </span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>              <span class="op">.</span> <span class="fu">map</span> (clickButton s) </span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>              <span class="op">$</span> buttons ) </span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>              states</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">!</span>updatedCache <span class="ot">=</span> foldl&#39; (\acc k <span class="ot">-&gt;</span> Map.insert k (steps <span class="op">+</span> <span class="dv">1</span>) acc) cache b</span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">!</span>found <span class="ot">=</span> Map.member target updatedCache</span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> <span class="kw">if</span> <span class="fu">null</span> b <span class="kw">then</span> <span class="fu">error</span> <span class="st">&quot;unreachable&quot;</span> <span class="kw">else</span> <span class="kw">if</span> found </span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> (updatedCache, b)</span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> breadth (steps <span class="op">+</span> <span class="dv">1</span>) updatedCache b</span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a><span class="ot">  clickButton ::</span> <span class="dt">IntSet</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IntSet</span></span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a>  clickButton current button <span class="ot">=</span> </span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a>    foldl&#39; (toggleLight) current button</span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a>  toggleLight light button <span class="ot">=</span></span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> button <span class="ot">`Set.member`</span> light</span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> Set.delete button light</span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> Set.insert button light</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>With BFS handling the search for each individual light, the final
  solution just sums up the minimum button presses across all lights in
  our input.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb68"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> [<span class="dt">Light</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>solvePart1 <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> findMinButtonPresses</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> readFile&#39; <span class="st">&quot;assets/day10-input.txt&quot;</span> <span class="op">&gt;&gt;=</span> <span class="fu">print</span> <span class="op">.</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-9">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Unfortunately I haven’t been able to solve part 2 yet… So instead
  here’s a picture of my dog:</p>
  <figure>
  <img src="pepita.webp" alt="My dog Pepita" />
  <figcaption aria-hidden="true">My dog Pepita</figcaption>
  </figure>
  <p>I have a few idea of how to solve it:</p>
  <ol type="1">
  <li>Using a <a
  href="https://en.wikipedia.org/wiki/Linear_programming">linear
  programming</a> solver - to find the minimum of the set of linear
  equations</li>
  <li>Using an <a
  href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories">SMT</a>
  solver</li>
  <li>Brute forcing with a lot of optimizations + paralellism</li>
  </ol>
  <p>My first instinct was to go with idea #1 but I’ve spent too long
  now trying to make it work in haskell. Now I don’t have enough time to
  try idea #3 today but I’ll come back to it at some point.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb69"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> [<span class="dt">Light</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>solvePart2 <span class="ot">=</span> criesInUnsolved</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> criesInUnsolved <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;fml&quot;</span></span></code></pre></div>
  </div>
  </div>

    <script>
    // TOC Theme Toggle
    (function () {
      const toc = document.getElementById('TOC');
      const toggle = document.getElementById('theme-toggle');
      const icon = document.querySelector('.theme-icon');

      if (!toc || !toggle || !icon) return;

      // Load saved theme preference
      const savedTheme = localStorage.getItem('tocTheme') || 'light';
      if (savedTheme === 'dark') {
        toc.classList.add('dark-theme');
        icon.textContent = '🌙';
      }

      // Toggle theme on click
      toggle.addEventListener('click', function () {
        toc.classList.toggle('dark-theme');
        const isDark = toc.classList.contains('dark-theme');
        icon.textContent = isDark ? '🌙' : '☀️';
        localStorage.setItem('tocTheme', isDark ? 'dark' : 'light');
      });
    })();
  </script>
</body>

</html>
