<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet">
  <title>Day01</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { font-weight: bold; } /* Alert */
    code span.an { font-style: italic; } /* Annotation */
    code span.cf { font-weight: bold; } /* ControlFlow */
    code span.co { font-style: italic; } /* Comment */
    code span.cv { font-style: italic; } /* CommentVar */
    code span.do { font-style: italic; } /* Documentation */
    code span.er { font-weight: bold; } /* Error */
    code span.in { font-style: italic; } /* Information */
    code span.kw { font-weight: bold; } /* Keyword */
    code span.pp { font-weight: bold; } /* Preprocessor */
    code span.wa { font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=Libre+Baskerville:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
</head>
<body>
    <header id="title-block-header">
      <div>
        <div class='header-title'>Advent of Code 2025</div>
        <div class='header-subtitle'>in Haskell</div>
        <div class='header-meta'>
          <div class='header-author'>by Hugo Vilela</div>
          <div class='header-date'>December 2025</div>
        </div>
      </div>
  </header>
    <nav id="TOC" role="doc-toc" class="row">
    <h2>Table of Contents:</h2>
    <ul>
    <li><a href="#day-1" id="toc-day-1">Day 1</a>
    <ul>
    <li><a href="#part-1" id="toc-part-1">Part 1</a></li>
    <li><a href="#part-2" id="toc-part-2">Part 2</a></li>
    </ul></li>
    <li><a href="#day-2" id="toc-day-2">Day 2</a>
    <ul>
    <li><a href="#part-1-1" id="toc-part-1-1">Part 1</a></li>
    <li><a href="#part-2-1" id="toc-part-2-1">Part 2</a></li>
    </ul></li>
    <li><a href="#day-3" id="toc-day-3">Day 3</a>
    <ul>
    <li><a href="#part-1-2" id="toc-part-1-2">Part 1</a></li>
    <li><a href="#part-2-2" id="toc-part-2-2">Part 2</a></li>
    </ul></li>
    </ul>
  </nav>
  
  <h1 id="day-1">Day 1</h1>
  <h2 id="part-1">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today‚Äôs puzzle involves a combination lock with a rotating dial.
  We‚Äôre given a series of left (L) and right (R) rotations, and we need
  to count how many times the dial lands exactly on position 0 after
  completing each rotation.</p>
  <p>The dial has 100 positions (0-99) and starts at position 50.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb1"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>First, a few ceremonies‚Ä¶</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb2"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day01</span> <span class="kw">where</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section id="parsing-the-input" class="lhs">
  <h3>Parsing the Input</h3>
  <p>I like to start by establishing a model and parsing the input.</p>
  <p>A <code>List</code> of <code>Integer</code>s is a natural way to
  model rotations. We‚Äôll use <strong>positive integers</strong> for
  right rotations and <strong>negative integers</strong> for left
  rotations. This makes the math simpler later‚Äîwe can just add the
  rotation value to our current position.</p>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb3"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">map</span> parseLine <span class="op">.</span> <span class="fu">lines</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    parseLine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    parseLine (<span class="ch">&#39;R&#39;</span><span class="op">:</span>rest) <span class="ot">=</span> <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> rest</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    parseLine (<span class="ch">&#39;L&#39;</span><span class="op">:</span>rest) <span class="ot">=</span> <span class="fu">negate</span> <span class="op">$</span> <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> rest</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    parseLine _ <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section id="solving-part-1" class="lhs">
  <h3>Solving Part 1</h3>
  <p>To solve this, we‚Äôll fold over the list of rotations while
  maintaining a tuple of <code>(count, currentRotation)</code>:</p>
  <ul>
  <li><code>count</code>: the number of times we‚Äôve landed exactly on
  0</li>
  <li><code>currentRotation</code>: our current position on the
  dial</li>
  </ul>
  <p>The key insight: after each rotation, we check if our new position
  is divisible by 100 by using modulo (meaning we‚Äôre at position 0).</p>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb4"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>solvePart1 <span class="ot">=</span> <span class="fu">fst</span> <span class="op">.</span> foldl&#39; rotate (<span class="dv">0</span>, <span class="dv">50</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  rotate ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  rotate (count, currentRotation) rotation <span class="ot">=</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newRotation <span class="ot">=</span> currentRotation <span class="op">+</span> rotation</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        isZero <span class="ot">=</span> newRotation <span class="ot">`mod`</span> <span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (count <span class="op">+</span> <span class="kw">if</span> isZero <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>, newRotation)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>All that‚Äôs left is to compose parsing with solving:</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb5"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 increases the difficulty: now we need to track how many
  times the indicator <strong>passes through</strong> position 0,
  including positions crossed during a rotation (not just where it
  lands).</p>
  <p>For example, if we‚Äôre at position 80 and rotate right by 30, we
  pass through position 0 once during that rotation (80 ‚Üí 90 ‚Üí 100/0 ‚Üí
  10).</p>
  <h3 id="the-algorithm">The Algorithm</h3>
  <p>The base algorithm remains a fold over the rotation list, but now
  we need a more sophisticated way to count zero crossings:</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb6"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>solvePart2 rotations <span class="ot">=</span> <span class="fu">fst</span> <span class="op">$</span> foldl&#39; go (<span class="dv">0</span>, <span class="dv">50</span>) rotations</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  go ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  go (count, currentRotation) rotation <span class="ot">=</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newRotation <span class="ot">=</span> currentRotation <span class="op">+</span> rotation</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        clicks <span class="ot">=</span> numberOfClicks currentRotation rotation</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (count <span class="op">+</span> clicks, newRotation)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section id="counting-zero-crossings" class="lhs">
  <h3>Counting Zero Crossings</h3>
  <p>The <code>numberOfClicks</code> function calculates how many times
  we pass through zero during a single rotation.</p>
  <p>The logic breaks down as follows:</p>
  <ol type="1">
  <li><strong>Normalize the current position</strong> to be in range [0,
  99]</li>
  <li><strong>Calculate complete rotations</strong>: Dividing the
  rotation amount by 100 gives us how many full loops around the dial we
  make (<code>totalRotations</code>)</li>
  <li><strong>Check the remainder</strong>: After the complete
  rotations, does the remainder push us through 0?
  <ul>
  <li><strong>Right rotation</strong>: We pass through 0 if
  <code>currentPos + remainder &gt;= 100</code></li>
  <li><strong>Left rotation</strong>: We pass through 0 if we‚Äôre not
  already at 0 and <code>currentPos - remainder &lt;= 0</code></li>
  </ul></li>
  </ol>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb7"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">numberOfClicks ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>numberOfClicks pos rotation <span class="ot">=</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> actualPos <span class="ot">=</span> normalizeRotation pos</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>      (totalRotations, remainder) <span class="ot">=</span> <span class="fu">quotRem</span> (<span class="fu">abs</span> rotation) <span class="dv">100</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>      remainderClicks <span class="ot">=</span> <span class="kw">if</span> rotation <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> actualPos <span class="op">+</span> remainder <span class="op">&gt;=</span> <span class="dv">100</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> actualPos <span class="op">/=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> actualPos <span class="op">-</span> remainder <span class="op">&lt;=</span> <span class="dv">0</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> totalRotations <span class="op">+</span> <span class="kw">if</span> remainderClicks <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section id="handling-negative-positions" class="lhs">
  <h3>Handling Negative Positions</h3>
  <p>One edge case: Haskell‚Äôs <code>mod</code> operator doesn‚Äôt wrap
  negative numbers the way we need for a circular dial. We need a custom
  normalization function: This ensures that <code>-10</code> becomes
  <code>90</code>, <code>-110</code> becomes <code>90</code>, etc.</p>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb8"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">normalizeRotation ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>normalizeRotation n</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> n <span class="op">&gt;=</span> <span class="dv">0</span>    <span class="ot">=</span> n <span class="ot">`mod`</span> <span class="dv">100</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> (<span class="dv">100</span> <span class="op">-</span> (<span class="fu">abs</span> n) <span class="ot">`mod`</span> <span class="dv">100</span>) <span class="ot">`mod`</span> <span class="dv">100</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <section id="final-solution" class="lhs">
  <h3>Final Solution</h3>
  <p>And TA-DA!</p>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb9"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-2">Day 2</h1>
  <h2 id="part-1-1">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today‚Äôs problem was easier than expected, for part 1 we get a list
  of ranges. ie.</p>
  <div class="sourceCode" id="cb10"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(90 - 10000)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>(57 - 82345)</span></code></pre></div>
  <p>We need to find all invalidIds between each range and sum them. An
  id is invalid if it‚Äôs first and second half are equal (ie. 1010,
  123123, 88).</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb11"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day02</span> <span class="kw">where</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;))</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.Split</span> (chunksOf)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>As always, we start with parsing the input, a list of
  <code>(Int, Int)</code> seems fitting</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb12"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Range</span> <span class="ot">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Range</span>]</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> T.pack <span class="op">&gt;&gt;&gt;</span> T.splitOn <span class="st">&quot;,&quot;</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> parseRange</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    parseRange str <span class="ot">=</span> <span class="kw">let</span> [a, b] <span class="ot">=</span> T.splitOn <span class="st">&quot;-&quot;</span> str</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">in</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> <span class="op">$</span> T.unpack a, <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> <span class="op">$</span> T.unpack b)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Put simply, for each range we get the invalid ids and sum them</p>
  <p><code>invalidIdsInRange</code> - checks all numbers in a range,
  filters only the invalid ones and sums them</p>
  <p><code>isInvalid</code> - returns True if the number has even length
  and its first and second half are equal</p>
  <p>There really isn‚Äôt much to see here</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb13"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> parse <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> invalidIdsInRange <span class="op">&gt;&gt;&gt;</span> <span class="fu">sum</span> </span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    invalidIdsInRange ::</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    invalidIdsInRange (a, b) <span class="ot">=</span> <span class="fu">sum</span> <span class="op">$</span> <span class="fu">filter</span> isInvalid <span class="op">$</span> [a<span class="op">..</span>b]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    isInvalid ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    isInvalid n <span class="ot">=</span> <span class="kw">let</span> str <span class="ot">=</span> <span class="fu">show</span> n</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>                      [<span class="fu">fst</span>, <span class="fu">snd</span>] <span class="ot">=</span> chunksOf (<span class="fu">length</span> str <span class="ot">`div`</span> <span class="dv">2</span>) str</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">in</span> <span class="fu">even</span> (<span class="fu">length</span> str) <span class="op">&amp;&amp;</span> <span class="fu">fst</span> <span class="op">==</span> <span class="fu">snd</span></span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-1">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 bumps the difficulty slightly now an id is invalid if it
  consists of a number repeated 2 or more times, ie.</p>
  <ul>
  <li>111 (1 repeated 3 times)</li>
  <li>123123123 (123 repeated 3 times)</li>
  <li>88 (8 repeated 2 times)</li>
  </ul>
  <p><strong>Takeaway</strong>: we can check for divisors of the length
  of the string, break the string into that many chunks and check if all
  chunks are equal</p>
  <p>The only change here is in <code>isInvalid</code> where we get the
  divisors of length of number, and check if any of the divisors holds
  the property above</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb14"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> parse <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> invalidIdsInRange <span class="op">&gt;&gt;&gt;</span> <span class="fu">sum</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  invalidIdsInRange ::</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  invalidIdsInRange (a, b) <span class="ot">=</span> <span class="fu">sum</span> <span class="op">$</span> <span class="fu">filter</span> isInvalid <span class="op">$</span> [a<span class="op">..</span>b]</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  isInvalid ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  isInvalid n <span class="ot">=</span> <span class="kw">let</span> str <span class="ot">=</span> <span class="fu">show</span> <span class="op">$</span> n</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>                    divs <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span><span class="fu">length</span> str <span class="ot">`div`</span> <span class="dv">2</span>] <span class="op">&amp;</span> <span class="fu">filter</span> (\it <span class="ot">-&gt;</span> <span class="fu">length</span> str <span class="ot">`mod`</span> it <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span> <span class="fu">any</span> (allEqual <span class="op">.</span> <span class="fu">flip</span> chunksOf str) divs</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="ot">allEqual ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>allEqual (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">all</span> (<span class="op">==</span> x) xs</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>allEqual [] <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
  </div>
  </div>
  <h1 id="day-3">Day 3</h1>
  <h2 id="part-1-2">Part 1</h2>
  <div class="row">
  <section id="the-problem" class="lhs">
  <h3>The problem</h3>
  <p>Our puzzle input this time is a list of Int</p>
  <div class="sourceCode" id="cb15"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>987654321111111</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>811111111111119</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>234234234234278</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>818181911112111</span></code></pre></div>
  <p>each row is a bank of batteries our task is to find the maximum
  joltage for each bank and sum all of them</p>
  <p>In part 1 the maximum joltage of the bank is the biggest number
  resulting from picking any 2-digits in the bank (without changing
  their order)</p>
  </section>
  <div class="code">
  <div class="sourceCode" id="cb16"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TupleSections #-}</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day03</span> <span class="kw">where</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;), on)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span> (<span class="dt">Foldable</span>(foldMap&#39;))</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span> (<span class="dt">Sum</span>(<span class="dt">Sum</span>, getSum))</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sortBy)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Our model today is a <code>[[Int]]</code> we‚Äôre concerning
  ourselves with digits today.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb17"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Bank</span> <span class="ot">=</span> [<span class="dt">Int</span>]</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Parsing is straighforward, we split the string into lines and
  convert each char in each line to an Int</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb18"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">lines</span> </span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> <span class="op">.</span> (<span class="op">:</span>[])))</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>we calculate the joltage of each bank by generating all possible
  <code>batteryPairs</code> getting their joltage and picking the
  greatest.</p>
  <p>then we just sum and that‚Äôs it</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb19"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solve <span class="op">.</span> parse</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    solve ::</span> [<span class="dt">Bank</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    solve <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> getBankJoltage</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    getBankJoltage ::</span> <span class="dt">Bank</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    getBankJoltage <span class="ot">=</span> <span class="fu">maximum</span> <span class="op">.</span> allJoltagesInBank</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    allJoltagesInBank ::</span> <span class="dt">Bank</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    allJoltagesInBank <span class="ot">=</span> <span class="fu">map</span> (\(a, b) <span class="ot">-&gt;</span> a <span class="op">*</span> <span class="dv">10</span> <span class="op">+</span> b) <span class="op">.</span> batteryPairs</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    batteryPairs ::</span> <span class="dt">Bank</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    batteryPairs (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">map</span> (x,) xs <span class="op">&lt;&gt;</span> batteryPairs xs</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    batteryPairs [] <span class="ot">=</span> []</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-2">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 is a bit more interesting, this time we need to pick 12
  batteries to find the joltage.</p>
  <p>The key of this algorithm is starting backwards, to make it simple,
  let‚Äôs imagine a bank with 6 batteries where we need to pick 4 to find
  the joltage.</p>
  <p>Our first battery can be anywhere but the last 3 places, because in
  the ‚Äúworst case scenario‚Äù that the digits are in ascending order we
  still need 3 batteries after the first.</p>
  <p>The keypoint here is that we can greedily pick the greatest digit
  of those available, because we‚Äôre always picking the next most
  significant digit. In case there‚Äôs a tie we should pick the first one
  to give more choice to the next digits</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb20"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Most of part 2 is the same as part 1 except we have
  <code>getMaxJoltageOf</code> which takes the number of batteries
  needed to form a joltage and a bank and returns the maximum
  joltage</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb21"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | The solution for part2 is more efficient and could be used for part1 by using (getMaxJoltageOf 2)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solve <span class="op">.</span> parse</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    solve ::</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    solve <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> (getMaxJoltageOf <span class="dv">12</span>)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>For each digit we find the available positions and the return the
  greatest number in the earliest position.</p>
  <p>We achieve this through a fold keeping track of the greatest digit
  so far and its position</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb22"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- |returns the max joltage of taking `size` batteries in a bank</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    getMaxJoltageOf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    getMaxJoltageOf size digits <span class="ot">=</span> mergeDigits <span class="op">$</span> <span class="fu">reverse</span> <span class="op">$</span> go <span class="dv">0</span> <span class="dv">0</span> []</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="ot">        go ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        go n _ acc <span class="op">|</span> n <span class="op">==</span> size <span class="ot">=</span> acc</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- | recursively find the next best digit</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- when picking a digit we know what positions in the original array are valid</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- we pick the greatest digit and if there are multiple we pick the first</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        go ix <span class="fu">minBound</span> acc <span class="ot">=</span> <span class="kw">let</span> digitBounds <span class="ot">=</span> [<span class="fu">minBound</span><span class="op">..</span>(<span class="fu">length</span> digits <span class="op">-</span> size <span class="op">+</span> ix)]</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>                                 (maxDigitIx, maxDigit) <span class="ot">=</span> <span class="fu">head</span> <span class="op">.</span> sortBy (<span class="fu">compare</span> <span class="ot">`on`</span> <span class="fu">negate</span> <span class="op">.</span> <span class="fu">snd</span>) <span class="op">$</span> <span class="fu">map</span> (\(ix, ix2) <span class="ot">-&gt;</span> (ix, digits<span class="op">!!</span>ix2)) <span class="op">$</span> <span class="fu">zip</span> digitBounds digitBounds</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>                              <span class="kw">in</span> go (ix <span class="op">+</span> <span class="dv">1</span>) (maxDigitIx <span class="op">+</span><span class="dv">1</span>) (maxDigit<span class="op">:</span>acc)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>To merge digits into a number we just reverse them a multiply by 10
  to the power of its index.</p>
  <p>The traditional algorithm</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb23"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Merges digits into number. </span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- mergeDigits [1, 2, 3] === 123</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="ot">mergeDigits ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>mergeDigits xs <span class="ot">=</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] (<span class="fu">reverse</span> xs) </span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> foldMap&#39; (\(ix, d) <span class="ot">-&gt;</span> <span class="dt">Sum</span> (d <span class="op">*</span> <span class="dv">10</span> <span class="op">^</span> ix))</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> getSum</span></code></pre></div>
  </div>
  </div>

    <script>
    // TOC Theme Toggle
    (function() {
      const toc = document.getElementById('TOC');
      const toggle = document.getElementById('theme-toggle');
      const icon = document.querySelector('.theme-icon');

      if (!toc || !toggle || !icon) return;

      // Load saved theme preference
      const savedTheme = localStorage.getItem('tocTheme') || 'light';
      if (savedTheme === 'dark') {
        toc.classList.add('dark-theme');
        icon.textContent = 'üåô';
      }

      // Toggle theme on click
      toggle.addEventListener('click', function() {
        toc.classList.toggle('dark-theme');
        const isDark = toc.classList.contains('dark-theme');
        icon.textContent = isDark ? 'üåô' : '‚òÄÔ∏è';
        localStorage.setItem('tocTheme', isDark ? 'dark' : 'light');
      });
    })();
  </script>
</body>
</html>
