<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap" rel="stylesheet">
  <title>Day01</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { font-weight: bold; } /* Alert */
    code span.an { font-style: italic; } /* Annotation */
    code span.cf { font-weight: bold; } /* ControlFlow */
    code span.co { font-style: italic; } /* Comment */
    code span.cv { font-style: italic; } /* CommentVar */
    code span.do { font-style: italic; } /* Documentation */
    code span.er { font-weight: bold; } /* Error */
    code span.in { font-style: italic; } /* Information */
    code span.kw { font-weight: bold; } /* Keyword */
    code span.pp { font-weight: bold; } /* Preprocessor */
    code span.wa { font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=Libre+Baskerville:ital,wght@0,400..700;1,400..700&display=swap" rel="stylesheet">
</head>
<body>
    <header id="title-block-header">
      <div>
        <div class='header-title'>Advent of Code 2025</div>
        <div class='header-subtitle'>in Haskell</div>
        <div class='header-meta'>
          <div class='header-author'>by Hugo Vilela</div>
          <div class='header-date'>December 2025</div>
        </div>
      </div>
  </header>
    <nav id="TOC" role="doc-toc" class="row">
    <h2>Table of Contents:</h2>
    <ul>
    <li><a href="#day-1" id="toc-day-1">Day 1</a>
    <ul>
    <li><a href="#part-1" id="toc-part-1">Part 1</a></li>
    <li><a href="#part-2" id="toc-part-2">Part 2</a></li>
    </ul></li>
    <li><a href="#day-2" id="toc-day-2">Day 2</a>
    <ul>
    <li><a href="#part-1-1" id="toc-part-1-1">Part 1</a></li>
    <li><a href="#part-2-1" id="toc-part-2-1">Part 2</a></li>
    </ul></li>
    </ul>
  </nav>
  
  <h1 id="day-1">Day 1</h1>
  <h2 id="part-1">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>For today‚Äôs problem we have a list of left/right rotations to open
  a lock and need to count the number of times the dial rests at 0 after
  each rotation</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb1"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>First, a few ceremonies‚Ä¶</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb2"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day01</span> <span class="kw">where</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>I like to start with establishing a model and parsing the
  input.<br/><br/> A List of Integers is a good way to model rotations,
  negative ints being left rotations.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb3"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">map</span> parseLine <span class="op">.</span> <span class="fu">lines</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    parseLine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    parseLine (<span class="ch">&#39;R&#39;</span><span class="op">:</span>rest) <span class="ot">=</span> <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> rest</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    parseLine (<span class="ch">&#39;L&#39;</span><span class="op">:</span>rest) <span class="ot">=</span> <span class="fu">negate</span> <span class="op">$</span> <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> rest</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    parseLine _ <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>And to solve, we want to fold over the list of rotations keeping
  track of <code>(count, currentRotation)</code> where
  <code>count</code> is the number of times we land at 0 <br/> <br/>
  This is where the magic happens, we add the rotation we‚Äôre folding
  into the <code>currentRotation</code> and then use modulo to check if
  the <code>newRotation</code> is at zero</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb4"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>solvePart1 <span class="ot">=</span> <span class="fu">fst</span> <span class="op">.</span> foldl&#39; rotate (<span class="dv">0</span>, <span class="dv">50</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  rotate ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  rotate (count, currentRotation) rotation <span class="ot">=</span> </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newRotation <span class="ot">=</span> currentRotation  <span class="op">+</span> rotation</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        isZero <span class="ot">=</span> newRotation <span class="ot">`mod`</span> <span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (count <span class="op">+</span> <span class="kw">if</span> isZero <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>, newRotation)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>All that‚Äôs left is to define the function that solves after
  parsing.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb5"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part2 raises things up a notch, now we want to track the number of
  times the indicator goes through 0 (counting mid rotations as
  well)</p>
  <p>The base algorithm is the same, a fold over the list, the
  difference is in how we count the clicks</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb6"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>solvePart2 rotations <span class="ot">=</span> <span class="fu">fst</span> <span class="op">$</span> foldl&#39; go (<span class="dv">0</span>, <span class="dv">50</span>) rotations</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  go ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  go (count, currentRotation) rotation <span class="ot">=</span> </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newRotation <span class="ot">=</span> currentRotation  <span class="op">+</span> rotation</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        clicks <span class="ot">=</span> numberOfClicks currentRotation rotation</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (count <span class="op">+</span> clicks, newRotation)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>We want to count how many times the indicator went through zero
  when starting at <code>pos</code> and rotating
  <code>rotation</code>.<br/> We divide the rotation by 100 to get the
  number of rotations performed + the remainder which may guide us
  through 0 once more</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb7"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">numberOfClicks ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>numberOfClicks pos rotation <span class="ot">=</span> </span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> actualPos <span class="ot">=</span> normalizeRotation pos</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>      (totalRotations, remainder) <span class="ot">=</span> <span class="fu">quotRem</span> (<span class="fu">abs</span> rotation) <span class="dv">100</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>      remainderClicks <span class="ot">=</span> <span class="kw">if</span> rotation <span class="op">&gt;</span> <span class="dv">0</span> </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> actualPos <span class="op">+</span> remainder <span class="op">&gt;=</span> <span class="dv">100</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> actualPos <span class="op">/=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> actualPos <span class="op">-</span> remainder <span class="op">&lt;=</span> <span class="dv">0</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> totalRotations <span class="op">+</span> <span class="kw">if</span> remainderClicks <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>one edge case here as modulo doesn‚Äôt wrap around negative numbers
  as one might expect</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb8"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">normalizeRotation ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>normalizeRotation n</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> n <span class="op">&gt;=</span> <span class="dv">0</span>    <span class="ot">=</span> n <span class="ot">`mod`</span> <span class="dv">100</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> (<span class="dv">100</span> <span class="op">-</span> (<span class="fu">abs</span> n) <span class="ot">`mod`</span> <span class="dv">100</span>) <span class="ot">`mod`</span> <span class="dv">100</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>and TA-DA!</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb9"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-2">Day 2</h1>
  <h2 id="part-1-1">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>For part 1 we‚Äôre given a list of integer ranges (N-M) and are asked
  to count invalid ids where an id is invalid if the first part of it is
  equal to the second (eg. 123123)</p>
  <p>A few cerimonies</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb10"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day02</span> <span class="kw">where</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;))</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sort, nub)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>As always, we start with parsing.<br/> A tuple seems to be a
  fitting choice for a range. I chose to parse into a Tuple of Texts
  because it‚Äôs easier to manipulate the numbers. Range didn‚Äôt need to be
  polymorphic but alas, as it was written it stays.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb11"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Range</span> a <span class="ot">=</span> (a, a)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> [<span class="dt">Range</span> <span class="dt">T.Text</span>]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> T.splitOn <span class="st">&quot;,&quot;</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> parseRange</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> </span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    parseRange str <span class="ot">=</span> <span class="kw">let</span> [a, b] <span class="ot">=</span> T.splitOn <span class="st">&quot;-&quot;</span> str</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">in</span> (a, b)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Okay time to think this through‚Ä¶ let‚Äôs say we have the following
  range <code>(101-9999999999)</code> that‚Äôs a lot of numbers to check,
  what if instead we looked at numbers by their length? We know we can
  skip all numbers with odd lenghts 100-999 for example are invalid.
  What about the others? Well we only need to look at the first half. So
  for all the numbers with length 4 (ie. 9898) we can just list all
  2-digit numbers and then duplicate them (ie. 98 -&gt; 9898). <br><br>
  <strong><code>invalidIdsInRange</code></strong> gets all the invalid
  Ids in the lengths of range and keeps only those within bounds
  <br><br> <strong><code>invalidIdsByNumLength</code></strong> does the
  magic. Given a length (ie. 4) gets all possible numbers with half that
  length (ie. 2) and generates invalidIds by duplicating them <br><br>
  and VOILA we got ourselves part1 done.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb12"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> T.pack </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> parse </span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> <span class="fu">concatMap</span> invalidIdsInRange </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> <span class="fu">sum</span> </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    invalidIdsInRange ::</span> <span class="dt">Range</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    invalidIdsInRange (a, b) <span class="ot">=</span> [T.length a <span class="op">..</span> T.length b]</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>                               <span class="op">&amp;</span> <span class="fu">filter</span> <span class="fu">even</span>                          <span class="co">-- ^Only even length numbers, odd ones cannot be mirrored</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>                               <span class="op">&amp;</span> <span class="fu">concatMap</span> (invalidIdsByNumLength <span class="op">!!</span>) <span class="co">-- ^Get all invalidIds between those lengths</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>                               <span class="op">&amp;</span> <span class="fu">dropWhile</span> (<span class="op">&lt;</span> textRead <span class="op">@</span><span class="dt">Int</span> a)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>                               <span class="op">&amp;</span> <span class="fu">takeWhile</span> (<span class="op">&lt;=</span> textRead <span class="op">@</span><span class="dt">Int</span> b) </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- infinite list of all possible invalidIds by length</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="ot">    invalidIdsByNumLength ::</span> [[<span class="dt">Int</span>]]</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    invalidIdsByNumLength <span class="ot">=</span> [<span class="dv">0</span><span class="op">..</span>] </span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">&amp;</span> <span class="fu">map</span> (</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>          <span class="co">-- |List of invalidIds for this numLength, we generate the first half and then duplicate it</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>         <span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span>) <span class="op">.</span> <span class="fu">map</span> (\a <span class="ot">-&gt;</span> a <span class="op">&lt;&gt;</span> a) <span class="op">.</span> getNDigits  <span class="op">.</span> (<span class="ot">`div`</span> <span class="dv">2</span>)</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>      )</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-1">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Oh boy part 2 here we go, this time around an invalid ID is any
  number that has one number repeated 2 or more times.</p>
  <blockquote>
  <p><strong>Invalid Ids</strong> <br></p>
  <ul>
  <li><code>111 (1 repeated 3 times)</code></li>
  <li><code>10101010 (10 repeated 5 times)</code></li>
  <li><code>125125 (125 repeated 3 times)</code></li>
  </ul>
  </blockquote>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb13"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>My approach to solve it is based on the one above, we still go
  through each number length (ie. for range (100-9999) we go through
  lengths 3 and 4). this time, for each length we need to find.</p>
  <p>So we generate <code>invalidIdsByNumLength</code> an infinite list
  where the index corresponds to the length of the numbers and the value
  is a list of all invalidIds with that length.</p>
  <p>To calculate the invalid ids for a single length we need to find
  all divisors of that length.</p>
  <p>So for say length 6 we have divisors 1, 2 and 3. then we just need
  to generate all invalidIds that are repetitions of those divisors.</p>
  <blockquote>
  <p>Length 6</p>
  <ul>
  <li><strong>divisor 1</strong> - <code>XXXXXX</code></li>
  <li><strong>divisor 2</strong> - <code>XYXYXY</code></li>
  <li><strong>divisor 3</strong> - <code>XYZXYZ</code></li>
  </ul>
  </blockquote>
  <p>This is what <code>getInvalidIds</code> does, for a length, finds
  the divisors and for each divisor generate all possible numbers of
  that length and then replicate those numbers
  <code>(length/divisor)</code> times.</p>
  <p>The rest of the functions are just helpers to achieve this.</p>
  <p><code>numberByLength</code> is an infinite array where the index is
  the length and the values are all numbers of that length</p>
  <p><code>numLength</code> just tells you the length of a number</p>
  <p><code>getNDigits</code> returns all possible numbers of a given
  length.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb14"><pre
  class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> T.pack </span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> parse </span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> <span class="fu">concatMap</span> invalidIdsInRange</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> <span class="fu">sum</span> </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    invalidIdsInRange ::</span> <span class="dt">Range</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    invalidIdsInRange (a, b) <span class="ot">=</span> [T.length a <span class="op">..</span> T.length b] </span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>                               <span class="op">&amp;</span> <span class="fu">concatMap</span> (invalidIdsByNumLength <span class="op">!!</span>)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>                               <span class="op">&amp;</span> <span class="fu">dropWhile</span> (<span class="op">&lt;</span> textRead <span class="op">@</span><span class="dt">Int</span> a)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>                               <span class="op">&amp;</span> <span class="fu">takeWhile</span> (<span class="op">&lt;=</span> textRead <span class="op">@</span><span class="dt">Int</span> b) </span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- | list of invalidIds by length of number</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    invalidIdsByNumLength ::</span> [[<span class="dt">Int</span>]]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>    invalidIdsByNumLength <span class="ot">=</span> [<span class="dv">0</span><span class="op">..</span>] <span class="op">&amp;</span> <span class="fu">map</span> getInvalidIds</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span> getInvalidIds numLen <span class="ot">=</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span> prefixLengths <span class="ot">=</span> <span class="fu">filter</span> (\prefixLen <span class="ot">-&gt;</span> numLen <span class="ot">`rem`</span> prefixLen <span class="op">==</span> <span class="dv">0</span>) [<span class="dv">1</span><span class="op">..</span>(numLen <span class="op">-</span> <span class="dv">1</span>)]</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>                  <span class="co">-- | how many times we need to repeat a prefix to get back at numLen</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>                  prefixRepeats prefixLen <span class="ot">=</span> numLen <span class="ot">`quot`</span> prefixLen </span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>                  invalidIds <span class="ot">=</span> prefixLengths </span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>                    <span class="co">-- |generate all invalidIds by repeating the prefixes as needed</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>                    <span class="op">&amp;</span> <span class="fu">map</span> (\prefixLen <span class="ot">-&gt;</span> <span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> </span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>                            <span class="op">.</span> <span class="fu">concat</span> </span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>                            <span class="op">.</span> <span class="fu">replicate</span> (prefixRepeats prefixLen)) </span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>                        <span class="op">$</span> getNDigits prefixLen)</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>               <span class="kw">in</span> <span class="fu">sort</span> <span class="op">.</span> nub <span class="op">.</span> <span class="fu">concat</span> <span class="op">$</span> invalidIds</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a><span class="ot">    numbersByLength ::</span> [[<span class="dt">Int</span>]]</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>    numbersByLength <span class="ot">=</span> [<span class="dv">0</span><span class="op">..</span>] <span class="op">&amp;</span> <span class="fu">map</span> (<span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span>) <span class="op">.</span> getNDigits)</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a><span class="co">-- | ie. numLength 100 = 3</span></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a><span class="ot">numLength ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a>numLength <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">show</span></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a><span class="co">-- |Returns all Numbers with n digits in asc order</span></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a><span class="ot">getNDigits ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">Char</span>]]</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>getNDigits numChars <span class="ot">=</span> </span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> first <span class="ot">=</span> [<span class="ch">&#39;1&#39;</span><span class="op">..</span><span class="ch">&#39;9&#39;</span>]</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>      other <span class="ot">=</span> [<span class="ch">&#39;0&#39;</span><span class="op">..</span><span class="ch">&#39;9&#39;</span>]</span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a>      <span class="fu">all</span> <span class="ot">=</span> first <span class="op">:</span> <span class="fu">replicate</span> (numChars <span class="op">-</span> <span class="dv">1</span>) other</span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="fu">map</span> <span class="fu">reverse</span> <span class="op">$</span> foldl&#39; go ([<span class="st">&quot;&quot;</span>]) <span class="fu">all</span></span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a>   <span class="kw">where</span></span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a>    go acc digits <span class="ot">=</span> <span class="fu">flip</span> <span class="fu">concatMap</span> acc <span class="op">$</span> \str <span class="ot">-&gt;</span> <span class="fu">map</span> (<span class="op">:</span>str) digits</span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a><span class="ot">textRead ::</span> (<span class="dt">Read</span> a) <span class="ot">=&gt;</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> a</span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>textRead <span class="ot">=</span> <span class="fu">read</span> <span class="op">.</span> T.unpack </span></code></pre></div>
  </div>
  </div>

    <script>
    // TOC Theme Toggle
    (function() {
      const toc = document.getElementById('TOC');
      const toggle = document.getElementById('theme-toggle');
      const icon = document.querySelector('.theme-icon');

      if (!toc || !toggle || !icon) return;

      // Load saved theme preference
      const savedTheme = localStorage.getItem('tocTheme') || 'light';
      if (savedTheme === 'dark') {
        toc.classList.add('dark-theme');
        icon.textContent = 'üåô';
      }

      // Toggle theme on click
      toggle.addEventListener('click', function() {
        toc.classList.toggle('dark-theme');
        const isDark = toc.classList.contains('dark-theme');
        icon.textContent = isDark ? 'üåô' : '‚òÄÔ∏è';
        localStorage.setItem('tocTheme', isDark ? 'dark' : 'light');
      });
    })();
  </script>
</body>
</html>
