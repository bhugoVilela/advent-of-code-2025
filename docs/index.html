<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="" >

<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&display=swap"
    rel="stylesheet">
          <title>Day01</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { font-weight: bold; } /* Alert */
    code span.an { font-style: italic; } /* Annotation */
    code span.cf { font-weight: bold; } /* ControlFlow */
    code span.co { font-style: italic; } /* Comment */
    code span.cv { font-style: italic; } /* CommentVar */
    code span.do { font-style: italic; } /* Documentation */
    code span.er { font-weight: bold; } /* Error */
    code span.in { font-style: italic; } /* Information */
    code span.kw { font-weight: bold; } /* Keyword */
    code span.pp { font-weight: bold; } /* Preprocessor */
    code span.wa { font-style: italic; } /* Warning */
  </style>
    <link rel="stylesheet" href="style.css" />
        <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300..700&family=Libre+Baskerville:ital,wght@0,400..700;1,400..700&display=swap"
    rel="stylesheet">
</head>

<body>
    <header id="title-block-header">
    <div>
      <div class='header-title'>Advent of Code 2025</div>
      <div class='header-subtitle'>in Haskell</div>
      <div class='header-meta'>
        <div class='header-author'>by Hugo Vilela</div>
        <div class='header-date'>December 2025</div>
        <div class='header-credits'>based on 
          <a target="_blank" href="https://aoc.oppi.li/">The Book of Solves</a>
          by <a target="_blank" href="https://tangled.org/oppi.li">@oppi.li</a>

        </div>
      </div>
    </div>
  </header>
    <nav id="TOC" role="doc-toc">
    <h2>Table of Contents:</h2>
    <ul>
    <li><a href="#day-1" id="toc-day-1">Day 1</a>
    <ul>
    <li><a href="#part-1" id="toc-part-1">Part 1</a></li>
    <li><a href="#part-2" id="toc-part-2">Part 2</a></li>
    </ul></li>
    <li><a href="#day-2" id="toc-day-2">Day 2</a>
    <ul>
    <li><a href="#part-1-1" id="toc-part-1-1">Part 1</a></li>
    <li><a href="#part-2-1" id="toc-part-2-1">Part 2</a></li>
    </ul></li>
    <li><a href="#day-3" id="toc-day-3">Day 3</a>
    <ul>
    <li><a href="#part-1-2" id="toc-part-1-2">Part 1</a></li>
    <li><a href="#part-2-2" id="toc-part-2-2">Part 2</a></li>
    </ul></li>
    <li><a href="#day-4" id="toc-day-4">Day 4</a>
    <ul>
    <li><a href="#part-1-3" id="toc-part-1-3">Part 1</a></li>
    <li><a href="#part-2-3" id="toc-part-2-3">Part 2</a></li>
    </ul></li>
    <li><a href="#day-5" id="toc-day-5">Day 5</a>
    <ul>
    <li><a href="#part-1-4" id="toc-part-1-4">Part 1</a></li>
    <li><a href="#part-2-4" id="toc-part-2-4">Part 2</a></li>
    </ul></li>
    <li><a href="#day-6" id="toc-day-6">Day 6</a>
    <ul>
    <li><a href="#part-1-5" id="toc-part-1-5">Part 1</a></li>
    <li><a href="#part-2-5" id="toc-part-2-5">Part 2</a></li>
    </ul></li>
    <li><a href="#day-7" id="toc-day-7">Day 7</a>
    <ul>
    <li><a href="#part-1-6" id="toc-part-1-6">Part 1</a></li>
    <li><a href="#part-2-6" id="toc-part-2-6">Part 2</a></li>
    </ul></li>
    <li><a href="#day-8" id="toc-day-8">Day 8</a>
    <ul>
    <li><a href="#part-1-7" id="toc-part-1-7">Part 1</a></li>
    <li><a href="#part-2-7" id="toc-part-2-7">Part 2</a></li>
    </ul></li>
    <li><a href="#day-9" id="toc-day-9">Day 9</a>
    <ul>
    <li><a href="#part-1-8" id="toc-part-1-8">Part 1</a></li>
    <li><a href="#part-2-8" id="toc-part-2-8">Part 2</a></li>
    </ul></li>
    <li><a href="#day-10" id="toc-day-10">Day 10</a>
    <ul>
    <li><a href="#part-1-9" id="toc-part-1-9">Part 1</a></li>
    <li><a href="#part-2-9" id="toc-part-2-9">Part 2</a></li>
    </ul></li>
    <li><a href="#day-11" id="toc-day-11">Day 11</a>
    <ul>
    <li><a href="#part-1-10" id="toc-part-1-10">Part 1</a></li>
    <li><a href="#part-2-10" id="toc-part-2-10">Part 2</a></li>
    </ul></li>
    <li><a href="#day-12" id="toc-day-12">Day 12</a>
    <ul>
    <li><a href="#part-1-11" id="toc-part-1-11">Part 1</a></li>
    <li><a href="#part-2-11" id="toc-part-2-11">Part 2</a></li>
    </ul></li>
    </ul>
  </nav>
  
  <h1 id="day-1">Day 1</h1>
  <h2 id="part-1">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle involves a combination lock with a rotating dial.
  We’re given a series of left (L) and right (R) rotations, and we need
  to count how many times the dial lands exactly on position 0 after
  completing each rotation.</p>
  <p>The dial has 100 positions (0-99) and starts at position 50.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb1"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day01</span> <span class="kw">where</span></span></code></pre></div>
  </div>
  </div>
  <h3> Parsing the Input</h3>
  <div class="row">
  <div class="lhs">
  <p>Let’s start by modeling the problem. A list of integers is perfect
  for representing rotations—we’ll use <strong>positive
  integers</strong> for right rotations and <strong>negative
  integers</strong> for left rotations. This lets us simply add the
  rotation value to our current position without branching logic.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb2"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">map</span> parseLine <span class="op">.</span> <span class="fu">lines</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    parseLine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    parseLine (<span class="ch">&#39;R&#39;</span><span class="op">:</span>rest) <span class="ot">=</span> <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> rest</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    parseLine (<span class="ch">&#39;L&#39;</span><span class="op">:</span>rest) <span class="ot">=</span> <span class="fu">negate</span> <span class="op">$</span> <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> rest</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    parseLine _ <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
  </div>
  </div>
  <h3> Solving Part 1</h3>
  <div class="row">
  <div class="lhs">
  <p>To solve this, we’ll fold over the list of rotations while
  maintaining a tuple of <code>(count, currentRotation)</code>:</p>
  <ul>
  <li><code>count</code>: the number of times we’ve landed exactly on
  0</li>
  <li><code>currentRotation</code>: our current position on the
  dial</li>
  </ul>
  <p>After each rotation, we check if our new position modulo 100 equals
  0—meaning we’ve landed precisely on position 0.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb3"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>solvePart1 <span class="ot">=</span> <span class="fu">fst</span> <span class="op">.</span> foldl&#39; rotate (<span class="dv">0</span>, <span class="dv">50</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  rotate ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  rotate (count, currentRotation) rotation <span class="ot">=</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newRotation <span class="ot">=</span> currentRotation <span class="op">+</span> rotation</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        isZero <span class="ot">=</span> newRotation <span class="ot">`mod`</span> <span class="dv">100</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (count <span class="op">+</span> <span class="kw">if</span> isZero <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span>, newRotation)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>All that’s left is to compose parsing with solving:</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb4"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 increases the difficulty: now we need to track how many
  times the indicator <strong>passes through</strong> position 0,
  including positions crossed during a rotation (not just where it
  lands).</p>
  <p>For example, if we’re at position 80 and rotate right by 30, we
  pass through position 0 once during that rotation (80 → 90 → 100/0 →
  10).</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The Algorithm</h3>
  <div class="row">
  <div class="lhs">
  <p>The base algorithm remains a fold over the rotation list, but now
  we need a more sophisticated way to count zero crossings:</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb5"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>solvePart2 rotations <span class="ot">=</span> <span class="fu">fst</span> <span class="op">$</span> foldl&#39; go (<span class="dv">0</span>, <span class="dv">50</span>) rotations</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  go ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  go (count, currentRotation) rotation <span class="ot">=</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newRotation <span class="ot">=</span> currentRotation <span class="op">+</span> rotation</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        clicks <span class="ot">=</span> numberOfClicks currentRotation rotation</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (count <span class="op">+</span> clicks, newRotation)</span></code></pre></div>
  </div>
  </div>
  <h3> Counting Zero Crossings</h3>
  <div class="row">
  <div class="lhs">
  <p>The <code>numberOfClicks</code> function calculates how many times
  we pass through zero during a single rotation.</p>
  <p>The logic breaks down as follows:</p>
  <ol type="1">
  <li><strong>Normalize the current position</strong> to be in range [0,
  99]</li>
  <li><strong>Calculate complete rotations</strong>: Dividing the
  rotation amount by 100 gives us how many full loops around the dial we
  make (<code>totalRotations</code>)</li>
  <li><strong>Check the remainder</strong>: After the complete
  rotations, does the remainder push us through 0?
  <ul>
  <li><strong>Right rotation</strong>: We pass through 0 if
  <code>currentPos + remainder &gt;= 100</code></li>
  <li><strong>Left rotation</strong>: We pass through 0 if we’re not
  already at 0 and <code>currentPos - remainder &lt;= 0</code></li>
  </ul></li>
  </ol>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb6"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">numberOfClicks ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>numberOfClicks pos rotation <span class="ot">=</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> actualPos <span class="ot">=</span> normalizeRotation pos</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>      (totalRotations, remainder) <span class="ot">=</span> <span class="fu">quotRem</span> (<span class="fu">abs</span> rotation) <span class="dv">100</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>      remainderClicks <span class="ot">=</span> <span class="kw">if</span> rotation <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> actualPos <span class="op">+</span> remainder <span class="op">&gt;=</span> <span class="dv">100</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> actualPos <span class="op">/=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> actualPos <span class="op">-</span> remainder <span class="op">&lt;=</span> <span class="dv">0</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> totalRotations <span class="op">+</span> <span class="kw">if</span> remainderClicks <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span></code></pre></div>
  </div>
  </div>
  <h3> Handling Negative Positions</h3>
  <div class="row">
  <div class="lhs">
  <p>One important edge case: Haskell’s <code>mod</code> operator
  doesn’t wrap negative numbers the way we need for a circular dial. Our
  custom normalization function ensures that <code>-10</code> becomes
  <code>90</code>, <code>-110</code> becomes <code>90</code>, and so
  on—wrapping properly in the reverse direction.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb7"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">normalizeRotation ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>normalizeRotation n</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> n <span class="op">&gt;=</span> <span class="dv">0</span>    <span class="ot">=</span> n <span class="ot">`mod`</span> <span class="dv">100</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> (<span class="dv">100</span> <span class="op">-</span> (<span class="fu">abs</span> n) <span class="ot">`mod`</span> <span class="dv">100</span>) <span class="ot">`mod`</span> <span class="dv">100</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>With all the pieces in place, Part 2 comes together:</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb8"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-2">Day 2</h1>
  <h2 id="part-1-1">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle gives us a list of numeric ranges:</p>
  <div class="sourceCode" id="cb9"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(90 - 10000)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>(57 - 82345)</span></code></pre></div>
  <p>Our task: find all “invalid IDs” within each range and sum them
  together.</p>
  <p>An ID is invalid if its digits can be split into two equal halves.
  For example:</p>
  <ul>
  <li><code>1010</code> splits into <code>10</code> and <code>10</code>
  ✓ invalid</li>
  <li><code>123123</code> splits into <code>123</code> and
  <code>123</code> ✓ invalid</li>
  <li><code>88</code> splits into <code>8</code> and <code>8</code> ✓
  invalid</li>
  <li><code>123</code> has odd length ✗ valid</li>
  <li><code>1234</code> splits into <code>12</code> and <code>34</code>
  ✗ valid</li>
  </ul>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb10"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day02</span> <span class="kw">where</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;))</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.Split</span> (chunksOf)</span></code></pre></div>
  </div>
  </div>
  <h3> Parsing</h3>
  <div class="row">
  <div class="lhs">
  <p>The input is comma-separated ranges, which we’ll model as pairs of
  integers.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb11"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Range</span> <span class="ot">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Range</span>]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> T.pack <span class="op">&gt;&gt;&gt;</span> T.splitOn <span class="st">&quot;,&quot;</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> parseRange</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    parseRange str <span class="ot">=</span> <span class="kw">let</span> [a, b] <span class="ot">=</span> T.splitOn <span class="st">&quot;-&quot;</span> str</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">in</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> <span class="op">$</span> T.unpack a, <span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> <span class="op">$</span> T.unpack b)</span></code></pre></div>
  </div>
  </div>
  <h3> The Solution</h3>
  <div class="row">
  <div class="lhs">
  <p>The algorithm is straightforward: for each range, check every
  number to see if it’s invalid, sum those that are, then sum across all
  ranges.</p>
  <p>The <code>isInvalid</code> function checks if a number has even
  digit length and whether its first half equals its second half.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb12"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> parse <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> invalidIdsInRange <span class="op">&gt;&gt;&gt;</span> <span class="fu">sum</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    invalidIdsInRange ::</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    invalidIdsInRange (a, b) <span class="ot">=</span> <span class="fu">sum</span> <span class="op">$</span> <span class="fu">filter</span> isInvalid <span class="op">$</span> [a<span class="op">..</span>b]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    isInvalid ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    isInvalid n <span class="ot">=</span> <span class="kw">let</span> str <span class="ot">=</span> <span class="fu">show</span> n</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>                      [<span class="fu">fst</span>, <span class="fu">snd</span>] <span class="ot">=</span> chunksOf (<span class="fu">length</span> str <span class="ot">`div`</span> <span class="dv">2</span>) str</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">in</span> <span class="fu">even</span> (<span class="fu">length</span> str) <span class="op">&amp;&amp;</span> <span class="fu">fst</span> <span class="op">==</span> <span class="fu">snd</span></span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-1">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 generalizes the pattern: now an ID is invalid if it consists
  of any repeating segment, not just two halves. For example:</p>
  <ul>
  <li><code>111</code> → <code>1</code> repeated 3 times ✓ invalid</li>
  <li><code>123123123</code> → <code>123</code> repeated 3 times ✓
  invalid</li>
  <li><code>88</code> → <code>8</code> repeated 2 times ✓ invalid</li>
  <li><code>1234</code> → no repeating pattern ✗ valid</li>
  </ul>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The Key Insight</h3>
  <div class="row">
  <div class="lhs">
  <p>We need to find all possible chunk sizes that could divide the
  number evenly, then check if chunking by that size produces identical
  chunks.</p>
  <p>For a number with length 6, we check chunk sizes 1, 2, and 3
  (divisors of 6). If any chunking produces all-equal chunks, the number
  is invalid.</p>
  <p>The implementation changes only the <code>isInvalid</code>
  function—everything else stays the same.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb13"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> parse <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> invalidIdsInRange <span class="op">&gt;&gt;&gt;</span> <span class="fu">sum</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  invalidIdsInRange ::</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  invalidIdsInRange (a, b) <span class="ot">=</span> <span class="fu">sum</span> <span class="op">$</span> <span class="fu">filter</span> isInvalid <span class="op">$</span> [a<span class="op">..</span>b]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  isInvalid ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>  isInvalid n <span class="ot">=</span> <span class="kw">let</span> str <span class="ot">=</span> <span class="fu">show</span> n</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>                    divs <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span><span class="fu">length</span> str <span class="ot">`div`</span> <span class="dv">2</span>] <span class="op">&amp;</span> <span class="fu">filter</span> (\it <span class="ot">-&gt;</span> <span class="fu">length</span> str <span class="ot">`mod`</span> it <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span> <span class="fu">any</span> (allEqual <span class="op">.</span> <span class="fu">flip</span> chunksOf str) divs</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="ot">allEqual ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>allEqual (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">all</span> (<span class="op">==</span> x) xs</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>allEqual [] <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
  </div>
  </div>
  <h1 id="day-3">Day 3</h1>
  <h2 id="part-1-2">Part 1</h2>
  <h3> The Problem</h3>
  <div class="row">
  <div class="lhs">
  <p>Today’s input gives us rows of digits—think of each row as a “bank
  of batteries”:</p>
  <div class="sourceCode" id="cb14"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>987654321111111</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>811111111111119</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>234234234234278</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>818181911112111</span></code></pre></div>
  <p>Each digit represents a battery, and our job is to calculate the
  maximum “joltage” for each bank, then sum them all together.</p>
  <p>For Part 1, the joltage of a bank is determined by picking any two
  digits (in order, no reversing) and forming a two-digit number. For
  example, from <code>987654321111111</code>, we could pick the
  <code>9</code> and <code>8</code> to get <code>98</code>, or the
  <code>9</code> and <code>7</code> to get <code>97</code>. The maximum
  joltage is the largest such number we can form.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb15"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TupleSections #-}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day03</span> <span class="kw">where</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;), on)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span> (<span class="dt">Foldable</span>(foldMap&#39;))</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span> (<span class="dt">Sum</span>(<span class="dt">Sum</span>, getSum))</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sortBy)</span></code></pre></div>
  </div>
  </div>
  <h3> The Solution</h3>
  <div class="row">
  <div class="lhs">
  <p>Our data model is simple: a list of banks, where each bank is a
  list of digit values.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb16"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Bank</span> <span class="ot">=</span> [<span class="dt">Int</span>]</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Parsing is straightforward—we split into lines and convert each
  character to a single digit.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb17"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">lines</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>      <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> <span class="op">.</span> (<span class="op">:</span>[])))</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The algorithm: generate all possible pairs of digits (maintaining
  order), form two-digit numbers from each pair, and take the maximum.
  Sum across all banks for the final answer.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb18"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solve <span class="op">.</span> parse</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    solve ::</span> [<span class="dt">Bank</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    solve <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> getBankJoltage</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    getBankJoltage ::</span> <span class="dt">Bank</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    getBankJoltage <span class="ot">=</span> <span class="fu">maximum</span> <span class="op">.</span> allJoltagesInBank</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    allJoltagesInBank ::</span> <span class="dt">Bank</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    allJoltagesInBank <span class="ot">=</span> <span class="fu">map</span> (\(a, b) <span class="ot">-&gt;</span> a <span class="op">*</span> <span class="dv">10</span> <span class="op">+</span> b) <span class="op">.</span> batteryPairs</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    batteryPairs ::</span> <span class="dt">Bank</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>    batteryPairs (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">map</span> (x,) xs <span class="op">&lt;&gt;</span> batteryPairs xs</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    batteryPairs [] <span class="ot">=</span> []</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-2">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 escalates things: now we need to pick <strong>12
  digits</strong> to form a 12-digit number, and maximize
  <em>that</em>.</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The Greedy Insight</h3>
  <div class="row">
  <div class="lhs">
  <p>Here’s the key insight: we can solve this greedily by picking
  digits from most significant to least significant.</p>
  <p>Let’s think through a simpler example: picking 4 digits from a
  6-digit bank. The first digit we pick can’t be in the last 3
  positions—we need to leave room for the 3 digits that follow. Among
  the valid positions (first 3 positions), we pick the largest
  digit.</p>
  <p>If there’s a tie, we pick the <em>earliest</em> occurrence. Why?
  Because choosing earlier gives us more options for subsequent
  digits—we preserve flexibility down the line.</p>
  <p>Once we’ve picked the first digit, we repeat the process for the
  second digit (starting from just after our first pick), then the
  third, and so on.</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> Implementation</h3>
  <div class="row">
  <div class="lhs">
  <p>The structure mirrors Part 1, except we use
  <code>getMaxJoltageOf</code> to generalize to any number of digits (12
  in this case).</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb19"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | The solution for part2 is more efficient and could be used for part1 by using (getMaxJoltageOf 2)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solve <span class="op">.</span> parse</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    solve ::</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    solve <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> (getMaxJoltageOf <span class="dv">12</span>)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The <code>getMaxJoltageOf</code> function implements our greedy
  strategy. For each digit position, we calculate which indices in the
  original bank are valid candidates (ensuring we leave enough room for
  remaining digits), then pick the largest digit from those
  positions.</p>
  <p>The recursion tracks three things: how many digits we’ve picked so
  far, the minimum index we can pick from (to maintain order), and our
  accumulated result.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb20"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- |returns the max joltage of taking `size` batteries in a bank</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    getMaxJoltageOf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    getMaxJoltageOf size digits <span class="ot">=</span> mergeDigits <span class="op">$</span> <span class="fu">reverse</span> <span class="op">$</span> go <span class="dv">0</span> <span class="dv">0</span> []</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="ot">        go ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>        go n _ acc <span class="op">|</span> n <span class="op">==</span> size <span class="ot">=</span> acc</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- | recursively find the next best digit</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- when picking a digit we know what positions in the original array are valid</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- we pick the greatest digit and if there are multiple we pick the first</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>        go ix <span class="fu">minBound</span> acc <span class="ot">=</span> <span class="kw">let</span> digitBounds <span class="ot">=</span> [<span class="fu">minBound</span><span class="op">..</span>(<span class="fu">length</span> digits <span class="op">-</span> size <span class="op">+</span> ix)]</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>                                 (maxDigitIx, maxDigit) <span class="ot">=</span> <span class="fu">head</span> <span class="op">.</span> sortBy (<span class="fu">compare</span> <span class="ot">`on`</span> <span class="fu">negate</span> <span class="op">.</span> <span class="fu">snd</span>) <span class="op">$</span> <span class="fu">map</span> (\(ix, ix2) <span class="ot">-&gt;</span> (ix, digits<span class="op">!!</span>ix2)) <span class="op">$</span> <span class="fu">zip</span> digitBounds digitBounds</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>                              <span class="kw">in</span> go (ix <span class="op">+</span> <span class="dv">1</span>) (maxDigitIx <span class="op">+</span><span class="dv">1</span>) (maxDigit<span class="op">:</span>acc)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Finally, we need to merge our list of digits into an actual number.
  We reverse the list (since we built it backwards), then combine digits
  by multiplying each by the appropriate power of 10 based on its
  position.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb21"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Merges digits into number.</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- mergeDigits [1, 2, 3] === 123</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ot">mergeDigits ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>mergeDigits xs <span class="ot">=</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] (<span class="fu">reverse</span> xs)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> foldMap&#39; (\(ix, d) <span class="ot">-&gt;</span> <span class="dt">Sum</span> (d <span class="op">*</span> <span class="dv">10</span> <span class="op">^</span> ix))</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>          <span class="op">&amp;</span> getSum</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-4">Day 4</h1>
  <h2 id="part-1-3">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle presents us with a 2D grid containing rolls of paper
  (marked with <code>@</code>) scattered among empty spaces.</p>
  <p>Our task: count how many rolls are <strong>accessible</strong>. A
  roll is accessible if it has fewer than 4 neighboring rolls in the 8
  adjacent positions (including diagonals). In other words, rolls that
  are too crowded (4+ neighbors) are inaccessible.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb22"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TupleSections #-}</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day04</span> <span class="kw">where</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashSet</span> (<span class="dt">HashSet</span>)</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.HashSet</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Linear.V2</span></span></code></pre></div>
  </div>
  </div>
  <h3> Data Representation</h3>
  <div class="row">
  <div class="lhs">
  <p>We’ll use <code>V2 Int</code> from the <code>linear</code> package
  to represent positions, and a <code>HashSet</code> to store the
  grid.</p>
  <p>Since we only care about where the rolls are (not empty spaces), we
  store just the positions containing rolls. This gives us efficient
  O(1) average-case lookups to check “is there a roll at this
  position?”</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb23"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Position</span> <span class="ot">=</span> <span class="dt">V2</span> <span class="dt">Int</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Grid</span> <span class="ot">=</span> <span class="dt">HashSet</span> <span class="dt">Position</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Grid</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>parse str <span class="ot">=</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  Set.fromList <span class="op">$</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    [ pos</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> (lineIx, line) <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] (<span class="fu">lines</span> str)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    , (colIx, char) <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] line</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    , <span class="kw">let</span> pos <span class="ot">=</span> <span class="dt">V2</span> lineIx colIx</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    , char <span class="op">==</span> <span class="ch">&#39;@&#39;</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>    ]</span></code></pre></div>
  </div>
  </div>
  <h3> The Solution</h3>
  <div class="row">
  <div class="lhs">
  <p>The solution filters the grid to keep only rolls with fewer than 4
  neighbors, then counts them.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb24"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> <span class="dt">Grid</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>solvePart1 grid <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> Set.filter ((<span class="op">&lt;</span><span class="dv">4</span>) <span class="op">.</span> getAdjacentRolls grid) <span class="op">$</span> grid</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The <code>getAdjacentRolls</code> helper generates all 8 adjacent
  positions (using vector addition) and counts how many contain
  rolls.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb25"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getAdjacentRolls ::</span> <span class="dt">Grid</span> <span class="ot">-&gt;</span> <span class="dt">Position</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>getAdjacentRolls grid pos <span class="ot">=</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="ot">`Set.member`</span> grid) <span class="op">.</span> <span class="fu">map</span> (pos <span class="op">+</span>) <span class="op">$</span> adjacentVectors</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    adjacentVectors ::</span> [<span class="dt">V2</span> <span class="dt">Int</span>]</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    adjacentVectors <span class="ot">=</span> [<span class="dt">V2</span> a b <span class="op">|</span> a <span class="ot">&lt;-</span> [<span class="op">-</span><span class="dv">1</span><span class="op">..</span><span class="dv">1</span>], b <span class="ot">&lt;-</span> [<span class="op">-</span><span class="dv">1</span><span class="op">..</span><span class="dv">1</span>], a <span class="op">/=</span> <span class="dv">0</span> <span class="op">||</span> b <span class="op">/=</span><span class="dv">0</span> ]</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-3">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 introduces a removal process: we repeatedly remove all
  accessible rolls (those with fewer than 4 neighbors) until no more can
  be removed. The answer is the total count of removed rolls.</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The Iterative Approach</h3>
  <div class="row">
  <div class="lhs">
  <p>This is a classic fixed-point iteration. Each round, we:</p>
  <ol type="1">
  <li>Identify accessible rolls (using our Part 1 logic)</li>
  <li>Remove them from the grid</li>
  <li>Repeat until the grid stops changing</li>
  </ol>
  <p>The trick: when we remove rolls, previously inaccessible rolls
  might become accessible (they now have fewer neighbors). So we keep
  iterating until we reach a stable state.</p>
  <p>The final answer is the difference between the original grid size
  and the final grid size.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb26"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> <span class="dt">Grid</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>solvePart2 grid <span class="ot">=</span> <span class="kw">let</span> finalGrid <span class="ot">=</span> removeAll grid</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">in</span> <span class="fu">length</span> grid <span class="op">-</span> <span class="fu">length</span> finalGrid</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Keep only inaccessible rolls (4+ neighbors)</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    removeOnce ::</span> <span class="dt">Grid</span> <span class="ot">-&gt;</span> <span class="dt">Grid</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    removeOnce grid <span class="ot">=</span> Set.filter (\pos <span class="ot">-&gt;</span> getAdjacentRolls grid pos <span class="op">&gt;=</span> <span class="dv">4</span>) grid</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Iterate until we reach a fixed point (grid stops changing)</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    removeAll ::</span> <span class="dt">Grid</span> <span class="ot">-&gt;</span> <span class="dt">Grid</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>    removeAll grid <span class="ot">=</span> <span class="kw">let</span> <span class="op">!</span>next <span class="ot">=</span> removeOnce grid</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">in</span> <span class="kw">if</span> Set.size next <span class="op">==</span> Set.size grid</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">then</span> grid</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">else</span> removeAll next</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-5">Day 5</h1>
  <h2 id="part-1-4">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle gives us a database containing two pieces of
  information:</p>
  <ol type="1">
  <li>A list of valid ranges (e.g., <code>100-500</code>,
  <code>600-1000</code>)</li>
  <li>A list of ID numbers to check</li>
  </ol>
  <p>Our task for Part 1: count how many of the given IDs fall within at
  least one of the valid ranges. An ID is “fresh” if it’s covered by any
  range.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb27"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-name-shadowing #-}</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day05</span> <span class="kw">where</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sortBy)</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> (on)</span></code></pre></div>
  </div>
  </div>
  <h3> Data Model</h3>
  <div class="row">
  <div class="lhs">
  <p>We’ll represent ranges as pairs of integers and bundle everything
  into a <code>Database</code> type for clean organization.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb28"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Range</span> <span class="ot">=</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Database</span> <span class="ot">=</span> <span class="dt">Database</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> ranges ::</span> [<span class="dt">Range</span>]</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> ids ::</span> [<span class="dt">Int</span>]</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
  </div>
  </div>
  <h3> Parsing</h3>
  <div class="row">
  <div class="lhs">
  <p>The input format has ranges first (one per line), then a blank
  line, then a list of IDs. We split on the blank line and parse each
  section accordingly.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb29"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Database</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>parse str <span class="ot">=</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> rows <span class="ot">=</span> <span class="fu">lines</span> str</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>      (rangeLines, idLines) <span class="ot">=</span> <span class="fu">break</span> (<span class="fu">null</span>) rows</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="dt">Database</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>        (<span class="fu">map</span> parseRange rangeLines)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        (<span class="fu">map</span> <span class="fu">read</span> <span class="op">$</span> <span class="fu">tail</span> idLines)</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseRange ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Range</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>  parseRange str <span class="ot">=</span> <span class="kw">let</span> (fst&#39;, snd&#39;) <span class="ot">=</span> <span class="fu">break</span> (<span class="op">==</span> <span class="ch">&#39;-&#39;</span>) str</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">in</span> (<span class="fu">read</span> fst&#39;, <span class="fu">read</span> <span class="op">.</span> <span class="fu">tail</span> <span class="op">$</span> snd&#39;)</span></code></pre></div>
  </div>
  </div>
  <h3> The Solution</h3>
  <div class="row">
  <div class="lhs">
  <p>Part 1 is straightforward: for each ID, check if any range contains
  it. Count the IDs that pass this test.</p>
  <p>The <code>contains</code> helper checks if a value falls within a
  range’s bounds (inclusive).</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb30"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> <span class="dt">Database</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>solvePart1 (<span class="dt">Database</span> ranges ids) <span class="ot">=</span> <span class="fu">length</span> <span class="op">$</span> <span class="fu">filter</span> isFresh ids</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  isFresh ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  isFresh <span class="fu">id</span> <span class="ot">=</span> <span class="fu">any</span> (contains <span class="fu">id</span>) ranges</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  contains ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>  contains <span class="fu">id</span> (<span class="fu">min</span>, <span class="fu">max</span>) <span class="ot">=</span> <span class="fu">id</span> <span class="op">&gt;=</span> <span class="fu">min</span> <span class="op">&amp;&amp;</span> <span class="fu">id</span> <span class="op">&lt;=</span> <span class="fu">max</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-4">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 asks a different question: what’s the total count of unique
  integers covered by all the ranges combined?</p>
  <p>For example, if we have ranges <code>1-5</code> and
  <code>3-8</code>, the unique integers covered are
  <code>[1,2,3,4,5,6,7,8]</code>, giving us a count of 8 (not 11, which
  would be if we counted overlaps twice).</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The Sorting Insight</h3>
  <div class="row">
  <div class="lhs">
  <p>The key insight: if we sort the ranges by their start position, we
  know that each subsequent range never starts before any previous
  range. This makes merging overlaps much simpler.</p>
  <p>As we fold through the sorted ranges, we track: - The previous
  range’s maximum value - The running count of unique integers
  covered</p>
  <p>For each new range, we calculate how many <em>new</em> integers it
  contributes by ensuring we don’t double-count overlaps with the
  previous range.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb31"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> <span class="dt">Database</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>solvePart2 <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> foldl&#39; addRange empty <span class="op">.</span> sortBy (<span class="fu">compare</span> <span class="ot">`on`</span> <span class="fu">fst</span>) <span class="op">.</span> ranges</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  countRange (<span class="fu">min</span>, <span class="fu">max</span>) <span class="ot">=</span> <span class="fu">max</span> <span class="op">-</span> <span class="fu">min</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  addRange ::</span> (<span class="dt">Range</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Range</span> <span class="ot">-&gt;</span> (<span class="dt">Range</span>, <span class="dt">Int</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>  addRange ((_, prevMax), count) (nextMin, nextMax) <span class="ot">=</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newRange <span class="ot">=</span> ( <span class="fu">max</span> nextMin (prevMax <span class="op">+</span> <span class="dv">1</span>), <span class="fu">max</span> nextMax prevMax)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (newRange, count <span class="op">+</span> countRange newRange)</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  empty ::</span> (<span class="dt">Range</span>, <span class="dt">Int</span>)</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>  empty <span class="ot">=</span> ((<span class="fu">undefined</span>, (<span class="op">-</span><span class="dv">2</span>)), <span class="dv">0</span>)</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-6">Day 6</h1>
  <h2 id="part-1-5">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle gives us a grid of numbers followed by a line of
  operations.</p>
  <p>The twist? We need to read the grid <strong>vertically</strong>
  (column by column) rather than horizontally. Each column of numbers
  gets paired with an operation from the last line, and we apply that
  operation to get a result. The final answer is the sum of all column
  results.</p>
  <p>For example, if a column is <code>[2, 3, 5]</code> and the
  operation is <code>+</code>, we get <code>10</code>. If the operation
  is <code>*</code>, we get <code>30</code>.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb32"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-name-shadowing #-}</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day06</span> <span class="kw">where</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (unsnoc, transpose)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span> (isSpace)</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;))</span></code></pre></div>
  </div>
  </div>
  <h3> Part 1 Solution</h3>
  <div class="row">
  <div class="lhs">
  <p>The algorithm is straightforward:</p>
  <ol type="1">
  <li>Split the input into rows and the final operations line</li>
  <li>Parse each row as space-separated numbers</li>
  <li><strong>Transpose</strong> to get columns instead of rows</li>
  <li>Zip operations with columns and apply each operation</li>
  <li>Sum the results</li>
  </ol>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb33"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>part1 str <span class="ot">=</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="dt">Just</span> (rows, opsLine) <span class="ot">=</span> unsnoc <span class="op">.</span> <span class="fu">lines</span> <span class="op">$</span> str</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="ot">      matrix ::</span> [[<span class="dt">Int</span>]]</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>      matrix <span class="ot">=</span> transpose <span class="op">.</span> <span class="fu">map</span> (<span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span>) <span class="op">.</span> <span class="fu">words</span>) <span class="op">$</span> rows</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>      ops <span class="ot">=</span> <span class="fu">words</span> opsLine</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> (<span class="fu">uncurry</span> getOp) <span class="op">$</span> <span class="fu">zip</span> ops matrix</span></code></pre></div>
  </div>
  </div>
  <h3> Operations</h3>
  <div class="row">
  <div class="lhs">
  <p>We support two operations: sum (<code>+</code>) and product
  (<code>*</code>).</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb34"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getOp ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>getOp <span class="st">&quot;+&quot;</span> <span class="ot">=</span> <span class="fu">sum</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>getOp <span class="st">&quot;*&quot;</span> <span class="ot">=</span> <span class="fu">product</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>getOp _ <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;unreachable&quot;</span></span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-5">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 changes the parsing rules. Now the grid can contain
  <strong>empty spaces</strong> within columns, and we need to treat
  sequences of numbers separated by spaces as distinct groups within
  each column.</p>
  <p>For example, a column might look like:</p>
  <pre><code>1
2

3
4</code></pre>
  <p>This represents two groups: <code>[1, 2]</code> and
  <code>[3, 4]</code>. We split on empty spaces, apply operations to
  each group separately, then sum everything.</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The Solution</h3>
  <div class="row">
  <div class="lhs">
  <p>The key difference is in how we process the transposed data:</p>
  <ol type="1">
  <li>Strip whitespace from each cell</li>
  <li>Split on empty strings to get groups</li>
  <li>Parse each group as numbers</li>
  <li>Apply operations as before</li>
  </ol>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb36"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>part2 str <span class="ot">=</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="dt">Just</span> (rows, opsLine) <span class="ot">=</span> unsnoc <span class="op">.</span> <span class="fu">lines</span> <span class="op">$</span> str</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>      numbers <span class="ot">=</span> rows</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>             <span class="op">&amp;</span> transpose</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>             <span class="op">&amp;</span> <span class="fu">map</span> (strip)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>             <span class="op">&amp;</span> splitOn <span class="fu">null</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>             <span class="op">&amp;</span> <span class="fu">map</span> (<span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span>))</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>      ops <span class="ot">=</span> <span class="fu">words</span> opsLine</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> (<span class="fu">uncurry</span> getOp) <span class="op">$</span> <span class="fu">zip</span> ops numbers</span></code></pre></div>
  </div>
  </div>
  <h3> Helper Functions</h3>
  <div class="row">
  <div class="lhs">
  <p>We need helpers to strip whitespace and split on a predicate.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb37"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ot">strip ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>strip <span class="ot">=</span> <span class="fu">dropWhile</span> (<span class="fu">isSpace</span>) <span class="op">&gt;&gt;&gt;</span> <span class="fu">takeWhile</span> (<span class="fu">not</span> <span class="op">.</span> <span class="fu">isSpace</span>)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="ot">splitOn ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>splitOn _ [] <span class="ot">=</span> []</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>splitOn fn xs <span class="ot">=</span> <span class="kw">let</span> (<span class="fu">group</span>, rest) <span class="ot">=</span> <span class="fu">break</span> fn xs</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>                    remaining <span class="ot">=</span> splitOn fn (<span class="fu">drop</span> <span class="dv">1</span> rest)</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span> <span class="kw">if</span> <span class="fu">null</span> <span class="fu">group</span> <span class="kw">then</span> remaining <span class="kw">else</span> <span class="fu">group</span> <span class="op">:</span> remaining</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-7">Day 7</h1>
  <h2 id="part-1-6">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle involves a beam of light traveling through a grid
  containing tachyons (represented by <code>^</code> symbols). The beam
  starts at position <code>S</code> and travels upward through
  columns.</p>
  <p>When the beam hits a tachyon, something interesting happens: it
  <strong>splits</strong> into two beams that move horizontally (one
  left, one right), then continue upward from their new positions.</p>
  <p>Our task: count how many unique tachyons the beam(s) will hit.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb38"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-name-shadowing #-}</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day07</span> <span class="kw">where</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;), on)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (find, sortBy, sort, uncons)</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashMap.Lazy</span> (<span class="dt">HashMap</span>, (!?))</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.HashMap.Lazy</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.HashSet</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashSet</span> (<span class="dt">HashSet</span>)</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (guard)</span></code></pre></div>
  </div>
  </div>
  <h3> Data Model</h3>
  <div class="row">
  <div class="lhs">
  <p>We need to track:</p>
  <ul>
  <li>Where the beam starts (<code>S</code> position)</li>
  <li>Where all the tachyons are (organized by column for efficient
  lookup)</li>
  </ul>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb39"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Instructions</span> <span class="ot">=</span> <span class="dt">Instructions</span> {</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  _start ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>),</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  _tachyons ::</span> <span class="dt">HashMap</span> <span class="dt">Int</span> [<span class="dt">Int</span>]  <span class="co">-- maps column x to list of y coordinates</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>} <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
  </div>
  </div>
  <h3> Parsing</h3>
  <div class="row">
  <div class="lhs">
  <p>We scan the grid for special characters: <code>S</code> marks the
  start position, and <code>^</code> marks tachyons. We organize
  tachyons by column and sort their y-coordinates for efficient upward
  traversal.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb40"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Instructions</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>parse str <span class="ot">=</span> <span class="kw">let</span><span class="ot"> chars ::</span> [(<span class="dt">Char</span>, (<span class="dt">Int</span>, <span class="dt">Int</span>))]</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>                chars <span class="ot">=</span> [ (c, (x, y))</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>                        <span class="op">|</span> (y, line) <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] (<span class="fu">lines</span> str)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>                        , (x, c)    <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] line</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>                        , c <span class="op">/=</span> <span class="ch">&#39;.&#39;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>                        ]</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Just</span> (_, start) <span class="ot">=</span> find (\(c, _) <span class="ot">-&gt;</span> c <span class="op">==</span> <span class="ch">&#39;S&#39;</span>) chars</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>                tachyons <span class="ot">=</span> chars</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;</span> <span class="fu">filter</span> (\(c, _) <span class="ot">-&gt;</span> c <span class="op">==</span> <span class="ch">&#39;^&#39;</span>)</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;</span> <span class="fu">map</span> <span class="fu">snd</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;</span> sortBy (<span class="fu">compare</span> <span class="ot">`on`</span> <span class="fu">fst</span>)</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;</span> groupBy <span class="fu">fst</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;</span> <span class="fu">map</span> (\col <span class="ot">-&gt;</span> (<span class="fu">fst</span> <span class="op">$</span> <span class="fu">head</span> col, <span class="fu">map</span> <span class="fu">snd</span> col))</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;</span> Map.fromList</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;</span> <span class="fu">fmap</span> (<span class="fu">sort</span>)</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>             <span class="kw">in</span> <span class="dt">Instructions</span> start tachyons</span></code></pre></div>
  </div>
  </div>
  <h3> Helper: Grouping</h3>
  <div class="row">
  <div class="lhs">
  <p>A simple grouping function that clusters consecutive elements with
  the same key.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb41"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">groupBy ::</span> (<span class="dt">Eq</span> b) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>groupBy fn [] <span class="ot">=</span> []</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>groupBy fn (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="kw">let</span> (<span class="fu">group</span>, rest) <span class="ot">=</span> <span class="fu">span</span> (\a <span class="ot">-&gt;</span> fn a <span class="op">==</span> fn x) xs</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">in</span> (x<span class="op">:</span><span class="fu">group</span>) <span class="op">:</span> groupBy fn rest</span></code></pre></div>
  </div>
  </div>
  <h3> The Algorithm</h3>
  <div class="row">
  <div class="lhs">
  <p>The beam simulation is a recursive traversal:</p>
  <ol type="1">
  <li>From the current position <code>(x, y)</code>, look up the column
  and find the next tachyon above the current y-coordinate</li>
  <li>If we find one and haven’t visited it yet:
  <ul>
  <li>Mark it as visited</li>
  <li>Remove it from the available tachyons</li>
  <li>Split: recursively simulate beams going left
  <code>(x-1, newY)</code> and right <code>(x+1, newY)</code></li>
  </ul></li>
  <li>If no tachyon found or already visited, return the current visited
  set</li>
  </ol>
  <p>The union of all visited tachyons gives us the answer.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb42"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> <span class="dt">Instructions</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>solvePart1 (<span class="dt">Instructions</span> start tachyons) <span class="ot">=</span> Set.size <span class="op">$</span> go <span class="fu">mempty</span> start tachyons</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">HashSet</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">HashMap</span> <span class="dt">Int</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">HashSet</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    go cache (x, y) tachyons <span class="ot">=</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> match <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>            col <span class="ot">&lt;-</span> tachyons <span class="op">!?</span> x</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>            (<span class="fu">head</span>, rest) <span class="ot">&lt;-</span> uncons <span class="op">$</span> <span class="fu">dropWhile</span> (<span class="op">&lt;</span> y) col</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>            guard <span class="op">$</span> <span class="fu">not</span> <span class="op">$</span> (x, <span class="fu">head</span>) <span class="ot">`Set.member `</span> cache</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> newMap <span class="ot">=</span> Map.insert x rest tachyons</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> (<span class="fu">head</span>, newMap)</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> <span class="kw">case</span> match <span class="kw">of</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> (newY, newMap) <span class="ot">-&gt;</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>              <span class="kw">let</span> newCache <span class="ot">=</span> Set.insert (x, newY) cache</span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>                  lhs <span class="ot">=</span> go newCache (x <span class="op">-</span> <span class="dv">1</span>, newY) newMap</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>                  rhs <span class="ot">=</span> go lhs (x <span class="op">+</span> <span class="dv">1</span>, newY) newMap</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>               <span class="kw">in</span> Set.union lhs rhs</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> cache</span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-6">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 asks: how many distinct <strong>paths</strong> does the beam
  take to reach the end?</p>
  <p>Instead of just counting visited tachyons, we now count all the
  different ways the beam can split and travel through the grid. This is
  a classic path-counting problem that benefits from
  <strong>memoization</strong>—if we reach the same tachyon from the
  same direction multiple times, the number of paths from there is
  always the same.</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The Memoized Solution</h3>
  <div class="row">
  <div class="lhs">
  <p>The algorithm is similar to Part 1, but now:</p>
  <ul>
  <li>We track a cache of <code>(position -&gt; path_count)</code>
  instead of a set</li>
  <li>When we reach a position we’ve seen before, return the cached
  count</li>
  <li>When we reach the end (no more tachyons), that’s 1 complete
  path</li>
  <li>The total count is the sum of paths going left and right at each
  split</li>
  </ul>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb43"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> <span class="dt">Instructions</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>solvePart2 (<span class="dt">Instructions</span> start tachyons) <span class="ot">=</span> <span class="fu">snd</span> <span class="op">$</span> go <span class="fu">mempty</span> start tachyons</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">HashMap</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">HashMap</span> <span class="dt">Int</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> (<span class="dt">HashMap</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    go cache (x, y) tachyons <span class="ot">=</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> match <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>            col <span class="ot">&lt;-</span> tachyons <span class="op">!?</span> x</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>            (<span class="fu">head</span>, rest) <span class="ot">&lt;-</span> uncons <span class="op">$</span> <span class="fu">dropWhile</span> (<span class="op">&lt;</span> y) col</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> newMap <span class="ot">=</span> Map.insert x rest tachyons</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> (<span class="fu">head</span>, newMap, cache <span class="op">Map.!?</span> (x, <span class="fu">head</span>))</span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> <span class="kw">case</span> match <span class="kw">of</span></span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> (newY, newMap, count) <span class="ot">-&gt;</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>              <span class="kw">case</span> count <span class="kw">of</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Just</span> n <span class="ot">-&gt;</span> (cache, n)  <span class="co">-- Cache hit!</span></span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">let</span> (leftCache, nl) <span class="ot">=</span> go cache (x <span class="op">-</span> <span class="dv">1</span>, newY) newMap</span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a>                               (rightCache, nr) <span class="ot">=</span> go leftCache (x <span class="op">+</span> <span class="dv">1</span>, newY) newMap</span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a>                               newCache <span class="ot">=</span> Map.insert (x, newY) (nl <span class="op">+</span> nr) <span class="op">$</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a>                                 Map.union leftCache rightCache</span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a>                           <span class="kw">in</span> (newCache, nl <span class="op">+</span> nr)</span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> (Map.empty, <span class="dv">1</span>)  <span class="co">-- Reached the end, count as 1 path</span></span>
<span id="cb43-21"><a href="#cb43-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-22"><a href="#cb43-22" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb43-23"><a href="#cb43-23" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-8">Day 8</h1>
  <h2 id="part-1-7">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle gives us electrical junctions floating in 3D space,
  each described by x,y,z coordinates:</p>
  <div class="sourceCode" id="cb44"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>162,817,812</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>57,618,57</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>906,360,560</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>...</span></code></pre></div>
  <p>Our task: repeatedly pick the two closest junctions and connect
  them into a circuit. This happens 1000 times, and each connection can
  play out in three ways:</p>
  <ul>
  <li><strong>Both unconnected</strong>: Create a new circuit containing
  both junctions</li>
  <li><strong>One connected</strong>: Add the unconnected junction to
  the existing circuit</li>
  <li><strong>Both connected</strong>: Merge their two circuits into
  one</li>
  </ul>
  <p>After 1000 connections, we multiply the sizes of the three largest
  circuits together.</p>
  <p>If this sounds like a job for a <strong>Union-Find (Disjoint
  Set)</strong> data structure, you’re absolutely right. That’s the
  textbook efficient solution for this kind of problem.</p>
  <p>Here’s the thing: this puzzle is actually <em>why</em> I learned
  about disjoint sets in the first place—but only <em>after</em> I’d
  already solved it my own way. So today we’ll walk through my original,
  more naive approach using the State monad and some good old
  hashmaps.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb45"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-name-shadowing #-}</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day08</span> <span class="kw">where</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Linear.V3</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> (on)</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.Split</span> (splitOn)</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span> (readFile&#39;)</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (sortBy)</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashMap.Strict</span> (<span class="dt">HashMap</span>, (!?) )</span>
<span id="cb45-14"><a href="#cb45-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.HashMap.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb45-15"><a href="#cb45-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Lens</span></span>
<span id="cb45-16"><a href="#cb45-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb45-17"><a href="#cb45-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State.Lazy</span> (<span class="dt">State</span>, evalState)</span>
<span id="cb45-18"><a href="#cb45-18" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM_)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Let’s start with our data model. We’ll use integers to identify
  circuits and 3D vectors from the <code>linear</code> library to
  represent junction positions.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb46"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CircuitId</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Junction</span> <span class="ot">=</span> (<span class="dt">V3</span> <span class="dt">Int</span>)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Parsing is straightforward—each line contains comma-separated x,y,z
  coordinates.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb47"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Junction</span>]</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">map</span> parseJunction <span class="op">.</span> <span class="fu">lines</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseJunction ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Junction</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>  parseJunction line <span class="ot">=</span> <span class="kw">let</span> [x, y, z] <span class="ot">=</span> splitOn <span class="st">&quot;,&quot;</span> line</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">in</span> <span class="dt">V3</span> (<span class="fu">read</span> x) (<span class="fu">read</span> y) (<span class="fu">read</span> z)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>For distance calculations, we use squared Euclidean distance. Since
  we only care about relative distances for sorting, we can skip the
  <code>sqrt</code>—it’s monotonic, so the ordering stays the same and
  we save some computation.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb48"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="ot">distanceTo ::</span> <span class="dt">Junction</span> <span class="ot">-&gt;</span> <span class="dt">Junction</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>distanceTo (<span class="dt">V3</span> x1 y1 z1) (<span class="dt">V3</span> x2 y2 z2) <span class="ot">=</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>         (<span class="fu">fromIntegral</span> (x2 <span class="op">-</span> x1)) <span class="op">**</span> <span class="fl">2.0</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>       <span class="op">+</span> (<span class="fu">fromIntegral</span> (y2 <span class="op">-</span> y1)) <span class="op">**</span> <span class="fl">2.0</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>       <span class="op">+</span> (<span class="fu">fromIntegral</span> (z2 <span class="op">-</span> z1)) <span class="op">**</span> <span class="fl">2.0</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The <code>distances</code> function generates all possible junction
  pairs and sorts them by distance, giving us a priority queue of
  connections to process.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb49"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">distances ::</span> [<span class="dt">Junction</span>] <span class="ot">-&gt;</span> [(<span class="dt">Junction</span>, <span class="dt">Junction</span>)]</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>distances vecs <span class="ot">=</span> [ (v1, v2)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>                 <span class="op">|</span> (ix, v1) <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] vecs</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>                 , v2 <span class="ot">&lt;-</span> <span class="fu">drop</span> (ix <span class="op">+</span> <span class="dv">1</span>) vecs</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>                 ] <span class="op">&amp;</span> sortBy (<span class="fu">compare</span> <span class="ot">`on`</span> <span class="fu">uncurry</span> distanceTo)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Now for the core state management. Our <code>ProblemState</code>
  tracks three things:</p>
  <ul>
  <li><strong><code>nextCircuitId</code></strong>: Counter for assigning
  IDs to new circuits</li>
  <li><strong><code>junctions</code></strong>: Maps each junction to its
  circuit ID (for fast “which circuit am I in?” lookups)</li>
  <li><strong><code>circuits</code></strong>: Maps each circuit ID to
  its junctions (for fast “what’s in this circuit?” lookups)</li>
  </ul>
  <p>This bidirectional indexing lets us efficiently handle all three
  connection cases.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb50"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ProblemState</span> <span class="ot">=</span> <span class="dt">ProblemState</span> {</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  _nextCircuitId ::</span> <span class="dt">CircuitId</span>,</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  _junctions ::</span> <span class="dt">HashMap</span> <span class="dt">Junction</span> <span class="dt">CircuitId</span>,</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  _circuits ::</span> <span class="dt">HashMap</span> <span class="dt">CircuitId</span> [<span class="dt">Junction</span>]</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="ot">emptyState ::</span> <span class="dt">ProblemState</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>emptyState <span class="ot">=</span> <span class="dt">ProblemState</span> <span class="dv">0</span> Map.empty Map.empty</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>We’re using the <strong>State monad</strong> combined with the
  <strong>lens library</strong> to keep our solution clean and readable.
  Lenses let us update nested state elegantly without the usual record
  update boilerplate. If you’re new to lenses, I highly recommend <a
  href="https://leanpub.com/optics-by-example/">Optics By
  Example</a>.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb51"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>makeLenses <span class="dt">&#39;ProblemState</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>We alias our computation type as <code>Solver</code> for
  clarity.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb52"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Solver</span> a <span class="ot">=</span> <span class="dt">State</span> <span class="dt">ProblemState</span> a</span></code></pre></div>
  </div>
  </div>
  <h3> Building blocks</h3>
  <div class="row">
  <div class="lhs">
  <p>Adding a junction to a circuit requires updating both indexes: we
  record which circuit the junction belongs to, and add the junction to
  that circuit’s member list.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb53"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addJunctionToCircuit ::</span> (<span class="dt">V3</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">CircuitId</span> <span class="ot">-&gt;</span> <span class="dt">Solver</span> ()</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>addJunctionToCircuit junction circuitId <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    junctions <span class="op">%=</span> Map.insert junction circuitId</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>    circuits <span class="op">%=</span> Map.alter (insert junction) circuitId</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> ()</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    insert ::</span> <span class="dt">V3</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">V3</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">V3</span> <span class="dt">Int</span>]</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>    insert junction <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Just</span> [junction]</span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>    insert junction (<span class="dt">Just</span> js) <span class="ot">=</span> <span class="dt">Just</span> (junction <span class="op">:</span> js)</span></code></pre></div>
  </div>
  </div>
  <h3> The core algorithm</h3>
  <div class="row">
  <div class="lhs">
  <p>Now for the heart of the solution: processing a junction pair.
  Given junctions <code>(a, b)</code>, we need to handle five distinct
  cases:</p>
  <ol type="1">
  <li><strong>Only <code>a</code> is connected</strong>: Add
  <code>b</code> to <code>a</code>’s circuit</li>
  <li><strong>Only <code>b</code> is connected</strong>: Add
  <code>a</code> to <code>b</code>’s circuit</li>
  <li><strong>Both in same circuit</strong>: Nothing to do</li>
  <li><strong>Both in different circuits</strong>: Merge them by moving
  all junctions from one circuit to the other, then delete the empty
  circuit</li>
  <li><strong>Neither connected</strong>: Create a new circuit
  containing both and increment our ID counter</li>
  </ol>
  <p>This is where things get interesting—and where a proper Union-Find
  structure would shine. But our State monad approach keeps the logic
  explicit and easy to follow.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb54"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addJunctionPair ::</span> (<span class="dt">V3</span> <span class="dt">Int</span>, <span class="dt">V3</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Solver</span> ()</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>addJunctionPair (a, b) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- find the circuits where a and b belong</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>  mCa <span class="ot">&lt;-</span> uses junctions (<span class="op">!?</span> a)</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>  mCb <span class="ot">&lt;-</span> uses junctions (<span class="op">!?</span> b)</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> (mCa, mCb) <span class="kw">of</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Just</span> ca, <span class="dt">Nothing</span>) <span class="ot">-&gt;</span> addJunctionToCircuit b ca</span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Nothing</span>, <span class="dt">Just</span> cb) <span class="ot">-&gt;</span> addJunctionToCircuit a cb</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Just</span> ca, <span class="dt">Just</span> cb) <span class="op">|</span> ca <span class="op">==</span> cb <span class="ot">-&gt;</span> <span class="fu">return</span> ()</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Just</span> ca, <span class="dt">Just</span> cb) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>      junctionsInCa <span class="ot">&lt;-</span> uses circuits (<span class="op">Map.!</span> ca)</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>      forM_ junctionsInCa <span class="op">$</span> <span class="fu">flip</span> addJunctionToCircuit cb</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>      circuits <span class="op">%=</span> Map.delete ca</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Nothing</span>, <span class="dt">Nothing</span>) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a>      nextId <span class="ot">&lt;-</span> use nextCircuitId </span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>      nextCircuitId <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>      addJunctionToCircuit a nextId</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>      addJunctionToCircuit b nextId</span></code></pre></div>
  </div>
  </div>
  <h3> Putting it together</h3>
  <div class="row">
  <div class="lhs">
  <p>With our machinery in place, Part 1 is straightforward:</p>
  <ol type="1">
  <li>Take the 1000 closest junction pairs</li>
  <li>Process each pair with our state-modifying function</li>
  <li>Find the three largest circuits and multiply their sizes</li>
  </ol>
  <p>That final one-liner does some heavy lifting: it extracts all
  circuits, maps to their sizes, sorts in descending order, takes the
  top 3, and multiplies them together.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb55"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> [<span class="dt">V3</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>solvePart1 junctions <span class="ot">=</span> <span class="fu">flip</span> evalState emptyState <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pairs <span class="ot">=</span> <span class="fu">take</span> <span class="dv">1000</span> <span class="op">$</span> distances junctions</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>  forM_ pairs addJunctionPair</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>  uses circuits (Map.toList <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">length</span> <span class="op">.</span> <span class="fu">snd</span>) <span class="op">&gt;&gt;&gt;</span> sortBy (<span class="fu">flip</span> <span class="fu">compare</span>) <span class="op">&gt;&gt;&gt;</span> <span class="fu">take</span> <span class="dv">3</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">product</span>)</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-7">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 asks a different question: <em>when</em> do all junctions
  get connected into a single unified circuit? We need to find the
  specific pair that completes this unification, then multiply their
  x-coordinates together.</p>
  <p>The beautiful part? We’ve already built everything we need. Our
  state tracks both the number of junctions assigned to circuits and the
  number of distinct circuits. When those numbers are equal to the total
  junction count and 1 respectively, we’re done.</p>
  <p>The <code>addUntilDone</code> helper processes pairs one by one
  until it hits that condition, then returns the winning pair. Multiply
  the x-coordinates, and we have our answer.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb56"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> [<span class="dt">V3</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>solvePart2 js <span class="ot">=</span> <span class="fu">flip</span> evalState emptyState <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pairs <span class="ot">=</span> distances js</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>      addUntilDone [] <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;unreachable&quot;</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>      addUntilDone (n<span class="op">:</span>rest) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>        addJunctionPair n</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>        junctionCount <span class="ot">&lt;-</span> uses junctions Map.size</span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>        circuitCount <span class="ot">&lt;-</span> uses circuits Map.size</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> junctionCount <span class="op">==</span> <span class="fu">length</span> js <span class="op">&amp;&amp;</span> circuitCount <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>          <span class="kw">then</span> <span class="fu">return</span> n</span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>          <span class="kw">else</span> addUntilDone rest</span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a>  (a, b) <span class="ot">&lt;-</span> addUntilDone pairs</span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> a<span class="op">^.</span>_x <span class="op">*</span> b<span class="op">^.</span>_x</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-9">Day 9</h1>
  <h2 id="part-1-8">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle gives us a collection of points scattered across a
  2D grid. Our task: find the largest rectangle we can form by choosing
  any two points as opposite corners.</p>
  <p>The twist? The rectangle’s sides must be axis-aligned (parallel to
  the x and y axes), and we count tiles inclusively—so a rectangle from
  (0,0) to (2,2) contains 9 tiles, not 4.</p>
  <p>Oooof, these imports are getting out of hand! But hey, we’ve got
  SVG rendering to do later.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb57"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-incomplete-patterns #-}</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day09</span> <span class="kw">where</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Linear.V2</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.Split</span> (splitOn)</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span> (readFile&#39;)</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;))</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Lens.Getter</span></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Blaze.Svg11</span> ((!), m)</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Blaze.Svg11</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Blaze.Svg11.Attributes</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Blaze.Svg.Renderer.String</span> (renderSvg)</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Printf</span> (printf)</span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.String</span> (<span class="dt">IsString</span>(fromString))</span>
<span id="cb57-17"><a href="#cb57-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Blaze.Svg</span> (mkPath)</span>
<span id="cb57-18"><a href="#cb57-18" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM_)</span>
<span id="cb57-19"><a href="#cb57-19" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Blaze.Svg11</span> (l)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The <code>linear</code> library’s <code>V2 Int</code> type is
  perfect for 2D points—it gives us vector operations for free if we
  need them later.</p>
  <p>Parsing is straightforward: each line contains comma-separated x,y
  coordinates.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb58"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Point</span> <span class="ot">=</span> <span class="dt">V2</span> <span class="dt">Int</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Point</span>]</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">lines</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> parseV2</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>  parseV2 line <span class="ot">=</span> <span class="kw">let</span> [x, y] <span class="ot">=</span> splitOn <span class="st">&quot;,&quot;</span> line</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>             <span class="kw">in</span> <span class="dt">V2</span> (<span class="fu">read</span> x) (<span class="fu">read</span> y)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>With a modest number of points, brute force is our friend. We check
  every possible pair of points, calculate the resulting rectangle’s
  area, and take the maximum.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb59"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> [<span class="dt">V2</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>solvePart1 tiles <span class="ot">=</span> </span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">maximum</span> [ area p1 p2 </span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> (ix, p1) <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">1</span><span class="op">..</span>] tiles</span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>          , p2 <span class="ot">&lt;-</span> <span class="fu">drop</span> ix tiles </span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>          ]</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The <code>area</code> function adds 1 to each dimension because
  we’re counting tiles inclusively—a rectangle from (0,0) to (2,2) spans
  3 units in each direction, giving us 3×3=9 tiles.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb60"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="ot">area ::</span> <span class="dt">V2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">V2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>area (<span class="dt">V2</span> x1 y1) (<span class="dt">V2</span> x2 y2) <span class="ot">=</span> (<span class="fu">abs</span> (y2 <span class="op">-</span> y1) <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> (<span class="fu">abs</span> (x2 <span class="op">-</span> x1) <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-8">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 cranks up the difficulty: now we need to find the largest
  rectangle that fits <em>inside</em> a polygon formed by connecting all
  the input points in sequence.</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> A stroke of luck</h3>
  <div class="row">
  <div class="lhs">
  <p>My first instinct was to implement the classic <a
  href="https://en.wikipedia.org/wiki/Point_in_polygon">raycast</a>
  algorithm for point-in-polygon testing. But that’s a lot of code for
  something I’ve written before, and—let’s be honest—it’s not that
  interesting the second time around.</p>
  <p>Instead, I got curious. What does the actual input look like? I
  whipped up a quick SVG visualization:</p>
  <figure>
  <img src="day09-input.svg" alt="day09 input svg" />
  <figcaption aria-hidden="true">day09 input svg</figcaption>
  </figure>
  <p><strong>Jackpot!</strong> The polygon is roughly circular with a
  narrow cut extending inward from the edge.</p>
  <p>This observation unlocks a much simpler approach: any rectangle
  large enough to be worth considering will be entirely on one side of
  that cut. It either fits in the “upper” region or the “lower”
  region—it can’t bridge across the cut without intersecting an
  edge.</p>
  <p>So instead of checking if every point inside a candidate rectangle
  is within the polygon, we just need to verify that the rectangle’s
  boundary doesn’t intersect any polygon edges.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb61"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="ot">drawInput ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>drawInput <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>  points <span class="ot">&lt;-</span> parse <span class="op">&lt;$&gt;</span> readFile&#39; <span class="st">&quot;assets/day09-input.txt&quot;</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> edges <span class="ot">=</span> <span class="kw">let</span> (p<span class="op">:</span>ps) <span class="ot">=</span> points <span class="kw">in</span> <span class="fu">zip</span> (p<span class="op">:</span>ps) (ps <span class="op">++</span> [p])</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>      maxX <span class="ot">=</span> points <span class="op">&amp;</span> <span class="fu">map</span> (view _x) <span class="op">&amp;</span> <span class="fu">maximum</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>      maxY <span class="ot">=</span> points <span class="op">&amp;</span> <span class="fu">map</span> (view _y) <span class="op">&amp;</span> <span class="fu">maximum</span> </span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a>      svgPath <span class="ot">=</span> mkPath <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a>        forM_ edges <span class="op">$</span> \(e1, e2) <span class="ot">-&gt;</span> <span class="kw">do</span> </span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a>          m (e1<span class="op">^.</span>_x) (e1<span class="op">^.</span>_y)</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>          l (e2<span class="op">^.</span>_x) (e2<span class="op">^.</span>_y)</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>      svg <span class="ot">=</span> renderSvg <span class="op">$</span> S.docTypeSvg <span class="op">!</span> A.version <span class="st">&quot;1.1&quot;</span> <span class="op">!</span> A.width <span class="st">&quot;400&quot;</span> <span class="op">!</span> A.height <span class="st">&quot;400&quot;</span> <span class="op">!</span> A.viewbox (fromString <span class="op">$</span> printf <span class="st">&quot;0 0 %d %d&quot;</span> maxX maxY) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>        S.path <span class="op">!</span> A.d svgPath <span class="op">!</span> A.strokeWidth <span class="st">&quot;400&quot;</span> <span class="op">!</span> A.stroke <span class="st">&quot;red&quot;</span>;</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> svg</span></code></pre></div>
  </div>
  </div>
  <h3> The solution</h3>
  <div class="row">
  <div class="lhs">
  <p>Armed with our insight, the solution mirrors Part 1’s brute
  force—except now we filter out any rectangle whose interior intersects
  with a polygon edge.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb62"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> [<span class="dt">V2</span> <span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>solvePart2 squares<span class="op">@</span>(p<span class="op">:</span>ps) <span class="ot">=</span> </span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>   <span class="kw">let</span> rectangles <span class="ot">=</span> [ (p1, p2)</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>                    <span class="op">|</span> (ix, p1) <span class="ot">&lt;-</span> <span class="fu">zip</span> [<span class="dv">1</span><span class="op">..</span>] squares</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>                    , p2 <span class="ot">&lt;-</span> <span class="fu">drop</span> ix squares</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>                    , <span class="fu">not</span> (intersects p1 p2 edges)</span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>                    ]</span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>       edges <span class="ot">=</span> <span class="fu">zip</span> (p<span class="op">:</span>ps) (ps <span class="op">++</span> [p])</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> <span class="fu">maximum</span> <span class="op">$</span> <span class="fu">map</span> (<span class="fu">uncurry</span> area) <span class="op">$</span> rectangles</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The <code>intersects</code> function checks if any polygon edge
  crosses through our candidate rectangle. We do this by testing whether
  the edge’s bounding box overlaps with the rectangle’s interior. If any
  edge overlaps, the rectangle is invalid.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb63"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="ot">intersects ::</span> <span class="dt">V2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">V2</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [(<span class="dt">V2</span> <span class="dt">Int</span>, <span class="dt">V2</span> <span class="dt">Int</span>)] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>intersects p1 p2 edges <span class="ot">=</span> <span class="fu">any</span> inside <span class="op">$</span> edges</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    inside ::</span> (<span class="dt">V2</span> <span class="dt">Int</span>, <span class="dt">V2</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>    inside (e1, e2) <span class="ot">=</span> <span class="fu">min</span> (e1<span class="op">^.</span>_x) (e2<span class="op">^.</span>_x) <span class="op">&lt;</span> maxX </span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>                     <span class="op">&amp;&amp;</span> <span class="fu">max</span> (e1<span class="op">^.</span>_x) (e2<span class="op">^.</span>_x) <span class="op">&gt;</span> minX </span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>                     <span class="op">&amp;&amp;</span> <span class="fu">min</span> (e1<span class="op">^.</span>_y) (e2<span class="op">^.</span>_y) <span class="op">&lt;</span> maxY </span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>                     <span class="op">&amp;&amp;</span> <span class="fu">max</span> (e1<span class="op">^.</span>_y) (e2<span class="op">^.</span>_y) <span class="op">&gt;</span> minY </span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>    minX <span class="ot">=</span> <span class="fu">min</span> (p1<span class="op">^.</span>_x) (p2<span class="op">^.</span>_x)</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>    maxX <span class="ot">=</span> <span class="fu">max</span> (p1<span class="op">^.</span>_x) (p2<span class="op">^.</span>_x)</span>
<span id="cb63-12"><a href="#cb63-12" aria-hidden="true" tabindex="-1"></a>    minY <span class="ot">=</span> <span class="fu">min</span> (p1<span class="op">^.</span>_y) (p2<span class="op">^.</span>_y)</span>
<span id="cb63-13"><a href="#cb63-13" aria-hidden="true" tabindex="-1"></a>    maxY <span class="ot">=</span> <span class="fu">max</span> (p1<span class="op">^.</span>_y) (p2<span class="op">^.</span>_y)</span>
<span id="cb63-14"><a href="#cb63-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-15"><a href="#cb63-15" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb63-16"><a href="#cb63-16" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h1 id="day-10">Day 10</h1>
  <h2 id="part-1-9">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Today’s puzzle presents us with a collection of lights, each
  composed of multiple LEDs. Our task: figure out the minimum number of
  button presses needed to configure each light to match a target
  pattern.</p>
  <p>Each light comes with three pieces of information:</p>
  <ul>
  <li><strong>Target configuration</strong>: a string like
  <code>[.##.]</code> where <code>#</code> represents an LED that should
  be ON and <code>.</code> represents one that should be OFF</li>
  <li><strong>Buttons</strong>: each button, when pressed, toggles
  specific LEDs (e.g., <code>(1,3)</code> toggles LEDs at indices 1 and
  3)</li>
  <li><strong>Joltages</strong>: power requirements we can safely ignore
  for Part 1</li>
  </ul>
  <p>For example, in
  <code>[.##.] (3) (1,3) (2) (2,3) (0,2) (0,1) {3,5,4,7}</code>: - We
  want LEDs at positions 1 and 2 to be ON, the rest OFF - We have six
  buttons available, each toggling different LED combinations - The
  joltages <code>{3,5,4,7}</code> don’t matter yet</p>
  <p>This is essentially a search problem: starting from all LEDs off,
  find the shortest sequence of button presses to reach the target
  configuration</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb64"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day10</span> <span class="kw">where</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (uncons)</span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Function</span> ((&amp;))</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.Split</span> (splitOn)</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span> (readFile&#39;)</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.HashMap.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashMap.Strict</span> (<span class="dt">HashMap</span>)</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.IntSet</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.IntSet</span> (<span class="dt">IntSet</span>)</span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Z3.Monad</span> <span class="kw">as</span> <span class="dt">Z</span></span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span> (catMaybes)</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM, forM_)</span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.IO.Unsafe</span> (unsafePerformIO)</span></code></pre></div>
  </div>
  </div>
  <h3> Modeling the problem</h3>
  <div class="row">
  <div class="lhs">
  <p>We’ll represent each light with a simple record type. The key
  insight is that we only care about <em>which</em> LEDs are on, not
  their order, so <code>IntSet</code> is perfect for tracking
  configurations efficiently.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb65"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Light</span> <span class="ot">=</span> <span class="dt">Light</span> {</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  _target ::</span> <span class="dt">IntSet</span>,</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  _buttons ::</span> [[<span class="dt">Int</span>]],</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  _joltages ::</span> [<span class="dt">Int</span>]</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>} <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Parsing this format is a bit fiddly—we need to strip brackets,
  parentheses, and curly braces, then split on commas and whitespace.
  Not the most elegant code I’ve written, but it gets the job done
  without pulling in heavy parsing libraries.</p>
  <p><strong>Reminder to Self</strong>: find better combinators for
  parsing. (Although I’d like to keep my solutions parsec and regex
  free)</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb66"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Light</span>]</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> <span class="fu">map</span> (parseLine <span class="op">.</span> <span class="fu">words</span>) <span class="op">.</span> <span class="fu">lines</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseLine ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Light</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>  parseLine <span class="fu">words</span> <span class="ot">=</span> </span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="dt">Just</span> (light, rest) <span class="ot">=</span> uncons <span class="fu">words</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>        (buttons, [joltages]) <span class="ot">=</span> <span class="fu">break</span> ((<span class="op">==</span> <span class="ch">&#39;{&#39;</span>) <span class="op">.</span> <span class="fu">head</span>) rest</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> <span class="dt">Light</span> (parseLight light) (<span class="fu">map</span> parseButton buttons) (parseJoltages joltages)</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseLight ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IntSet</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>  parseLight str <span class="ot">=</span> <span class="fu">filter</span> (\c <span class="ot">-&gt;</span> c <span class="op">/=</span> <span class="ch">&#39;[&#39;</span> <span class="op">&amp;&amp;</span> c <span class="op">/=</span> <span class="ch">&#39;]&#39;</span>) str</span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&amp;</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>]</span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&amp;</span> <span class="fu">filter</span> ((<span class="op">==</span> <span class="ch">&#39;#&#39;</span>) <span class="op">.</span> <span class="fu">snd</span>)</span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&amp;</span> <span class="fu">map</span> (<span class="fu">fst</span>)</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>                 <span class="op">&amp;</span> Set.fromList</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseButton ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>  parseButton <span class="ot">=</span> <span class="fu">filter</span> (\c <span class="ot">-&gt;</span> c <span class="op">/=</span> <span class="ch">&#39;(&#39;</span> <span class="op">&amp;&amp;</span> c <span class="op">/=</span> <span class="ch">&#39;)&#39;</span>) </span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>              <span class="op">&gt;&gt;&gt;</span> splitOn <span class="st">&quot;,&quot;</span></span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>              <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span>)</span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseJoltages ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a>  parseJoltages <span class="ot">=</span> <span class="fu">filter</span> (\c <span class="ot">-&gt;</span> c <span class="op">/=</span> <span class="ch">&#39;{&#39;</span> <span class="op">&amp;&amp;</span> c <span class="op">/=</span> <span class="ch">&#39;}&#39;</span>) <span class="op">&gt;&gt;&gt;</span> splitOn <span class="st">&quot;,&quot;</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span>)</span></code></pre></div>
  </div>
  </div>
  <h3> Finding the shortest path</h3>
  <div class="row">
  <div class="lhs">
  <p>When we want the <em>minimum</em> number of steps to reach a goal,
  breadth-first search (BFS) is our go-to algorithm. It explores all
  configurations reachable in N steps before trying any configuration
  that takes N+1 steps—guaranteeing we find the shortest path.</p>
  <p>Here’s the game plan: 1. Start with all LEDs off (empty
  <code>IntSet</code>) 2. For each configuration we’re exploring, try
  pressing every button 3. Track which configurations we’ve seen before
  to avoid cycles 4. Stop when we reach the target configuration</p>
  <p>The <code>breadth</code> function does the heavy lifting: -
  <code>states</code>: configurations we’re currently exploring -
  <code>cache</code>: a map recording how many steps it took to reach
  each configuration - <code>steps</code>: current depth in our
  search</p>
  <p>Each iteration generates new configurations by clicking every
  possible button on every current state, filters out ones we’ve seen
  before, and continues until we hit the target</p>
  <p>The helper functions are straightforward: <code>clickButton</code>
  applies a button press to a configuration by toggling each LED the
  button affects, and <code>toggleLight</code> flips a single LED on or
  off.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb67"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="ot">findMinButtonPresses ::</span> <span class="dt">Light</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>findMinButtonPresses (<span class="dt">Light</span> target buttons _) <span class="ot">=</span> </span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (cache, _) <span class="ot">=</span> breadth <span class="dv">0</span> (Map.singleton Set.empty <span class="dv">0</span>)[ Set.empty ]</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> cache <span class="op">Map.!</span> target</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  breadth ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">HashMap</span> <span class="dt">IntSet</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">IntSet</span>] <span class="ot">-&gt;</span> (<span class="dt">HashMap</span> <span class="dt">IntSet</span> <span class="dt">Int</span>, [<span class="dt">IntSet</span>])</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>  breadth steps cache states <span class="ot">=</span> </span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="op">!</span>b <span class="ot">=</span> <span class="fu">concatMap</span> (\s <span class="ot">-&gt;</span> </span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>              <span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> (<span class="fu">flip</span> Map.member cache)) </span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>              <span class="op">.</span> <span class="fu">map</span> (clickButton s) </span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a>              <span class="op">$</span> buttons ) </span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>              states</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">!</span>updatedCache <span class="ot">=</span> foldl&#39; (\acc k <span class="ot">-&gt;</span> Map.insert k (steps <span class="op">+</span> <span class="dv">1</span>) acc) cache b</span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">!</span>found <span class="ot">=</span> Map.member target updatedCache</span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> <span class="kw">if</span> <span class="fu">null</span> b <span class="kw">then</span> <span class="fu">error</span> <span class="st">&quot;unreachable&quot;</span> <span class="kw">else</span> <span class="kw">if</span> found </span>
<span id="cb67-16"><a href="#cb67-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> (updatedCache, b)</span>
<span id="cb67-17"><a href="#cb67-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> breadth (steps <span class="op">+</span> <span class="dv">1</span>) updatedCache b</span>
<span id="cb67-18"><a href="#cb67-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-19"><a href="#cb67-19" aria-hidden="true" tabindex="-1"></a><span class="ot">  clickButton ::</span> <span class="dt">IntSet</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IntSet</span></span>
<span id="cb67-20"><a href="#cb67-20" aria-hidden="true" tabindex="-1"></a>  clickButton current button <span class="ot">=</span> </span>
<span id="cb67-21"><a href="#cb67-21" aria-hidden="true" tabindex="-1"></a>    foldl&#39; (toggleLight) current button</span>
<span id="cb67-22"><a href="#cb67-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-23"><a href="#cb67-23" aria-hidden="true" tabindex="-1"></a>  toggleLight light button <span class="ot">=</span></span>
<span id="cb67-24"><a href="#cb67-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> button <span class="ot">`Set.member`</span> light</span>
<span id="cb67-25"><a href="#cb67-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> Set.delete button light</span>
<span id="cb67-26"><a href="#cb67-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> Set.insert button light</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>With BFS handling the search for each individual light, the final
  solution just sums up the minimum button presses across all lights in
  our input.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb68"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> [<span class="dt">Light</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>solvePart1 <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> findMinButtonPresses</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-9">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 adds a delightful twist: now we need to consider the
  <strong>joltages</strong>—those power requirements we ignored in Part
  1. Each button press consumes power from specific joltage sources, and
  we need to find the minimum number of button presses that both:</p>
  <ol type="1">
  <li>Achieves the target LED configuration</li>
  <li>Uses <em>exactly</em> the specified amount of power from each
  joltage source</li>
  </ol>
  <p>For example, if joltage 0 must total exactly 7, and buttons
  <code>(0,2)</code> and <code>(1,3)</code> both draw from joltage 0,
  then we need to press those buttons a combined total of 7 times. The
  challenge is finding a combination of button presses that satisfies
  all joltage constraints simultaneously while minimizing total
  presses.</p>
  <p>This transforms our simple BFS problem into something much more
  sophisticated: a constrained optimization problem.</p>
  <p>Unfortunately I couldn’t solve part 2 initially… So instead here’s
  a picture of my dog:</p>
  <figure>
  <img src="pepita.webp" alt="My dog Pepita" />
  <figcaption aria-hidden="true">My dog Pepita</figcaption>
  </figure>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> SOLVED! Enter the SMT solver</h3>
  <div class="row">
  <div class="lhs">
  <p><em>This is Hugo from the future!</em> I’ve finally been able to
  link Z3 with Haskell on my MacBook. I’m relatively new to Z3 and SMT
  (Satisfiability Modulo Theories) solvers in general, so this was a
  great learning opportunity.</p>
  <p><strong>What’s an SMT solver?</strong> Think of it as a constraint
  satisfaction engine on steroids. You describe your problem as a set of
  mathematical constraints (equations, inequalities, logical formulas),
  specify what you want to minimize or maximize, and the solver finds a
  solution that satisfies everything—if one exists.</p>
  <p>Z3, developed by Microsoft Research, is one of the most powerful
  SMT solvers available. It’s used for everything from program
  verification to test case generation. And for our puzzle? It’s
  perfect!</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> Reframing as constrained optimization</h3>
  <div class="row">
  <div class="lhs">
  <p>The key insight is recognizing this as a system of linear equations
  with an optimization goal. Let’s break it down:</p>
  <p><strong>Variables</strong>: For each button <code>i</code>, let
  <code>button_i</code> represent the number of times we press it.</p>
  <p><strong>Objective function</strong> (what we want to minimize):</p>
  <div class="sourceCode" id="cb69"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>total_presses = button_0 + button_1 + ... + button_n</span></code></pre></div>
  <p><strong>Constraints</strong> (conditions that must be
  satisfied):</p>
  <ol type="1">
  <li><p><strong>Non-negativity</strong>: We can’t press a button a
  negative number of times</p>
  <div class="sourceCode" id="cb70"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>button_i ≥ 0  (for all i)</span></code></pre></div></li>
  <li><p><strong>Joltage requirements</strong>: For each joltage source,
  the sum of button presses that draw from that source must equal the
  required total</p>
  <div class="sourceCode" id="cb71"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>Σ(button_i where button i affects joltage j) = joltage_j</span></code></pre></div></li>
  </ol>
  <p>For example, if buttons 2, 5, and 7 all draw from joltage source 3,
  and joltage 3 requires 15 total power, then:</p>
  <div class="sourceCode" id="cb72"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>button_2 + button_5 + button_7 = 15</span></code></pre></div>
  <p>This is a classic <strong>Integer Linear Programming (ILP)</strong>
  problem—and Z3 excels at solving these!</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> Building the constraint system</h3>
  <div class="row">
  <div class="lhs">
  <p>First, we need to extract our linear equations from the puzzle
  input. For each joltage source, we identify which buttons affect
  it.</p>
  <p>Remember: button index <code>i</code> in the buttons list affects
  joltage <code>j</code> if <code>j</code> appears in that button’s
  list. So for joltage source 2, we scan through all buttons looking for
  those that mention index 2.</p>
  <p>The result is a list of tuples:
  <code>(required_joltage, [button_indices])</code> where each tuple
  represents one constraint equation.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb73"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getLinearEquations ::</span> <span class="dt">Light</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, [<span class="dt">Int</span>])]</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>getLinearEquations (<span class="dt">Light</span> _ buttons joltages) <span class="ot">=</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">flip</span> <span class="fu">map</span> (enumerated joltages) <span class="op">$</span> \(jix, joltage) <span class="ot">-&gt;</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> buttons&#39; <span class="ot">=</span> (enumerated buttons) </span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">&amp;</span> <span class="fu">filter</span> (<span class="fu">any</span> (<span class="op">==</span> jix) <span class="op">.</span> <span class="fu">snd</span>) </span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a>            <span class="op">&amp;</span> <span class="fu">map</span> <span class="fu">fst</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> (joltage, buttons&#39;)</span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a><span class="ot">enumerated ::</span> [b] <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, b)]</span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>enumerated <span class="ot">=</span> <span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>]</span></code></pre></div>
  </div>
  </div>
  <h3> Translating to Z3</h3>
  <div class="row">
  <div class="lhs">
  <p>Now comes the fun part: encoding our problem in Z3. The Haskell
  bindings are… let’s say “functional but verbose.” Everything is done
  monadically through the <code>Z3</code> monad, which handles the
  interaction with the underlying solver.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb74"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="ot">script ::</span> <span class="dt">Light</span> <span class="ot">-&gt;</span> <span class="dt">Z.Z3</span> <span class="dt">Int</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>script light<span class="op">@</span>(<span class="dt">Light</span> _ buttons _) <span class="ot">=</span> <span class="kw">do</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p><strong>Step 1: Create decision variables</strong></p>
  <p>We create one integer variable per button. These represent our
  unknowns—the number of times each button will be pressed in the
  optimal solution.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb75"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>  vars <span class="ot">&lt;-</span> forM [<span class="dv">0</span><span class="op">..</span><span class="fu">length</span> buttons <span class="op">-</span> <span class="dv">1</span>] <span class="op">$</span> Z.mkFreshIntVar <span class="op">.</span> <span class="fu">show</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p><strong>Step 2: Add non-negativity constraints</strong></p>
  <p>Each variable must be ≥ 0 since we can’t press a button a negative
  number of times. We use <code>Z.optimizeAssert</code> to add each
  constraint to our optimization problem.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb76"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>  forM_ vars <span class="op">$</span> \var <span class="ot">-&gt;</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    Z.optimizeAssert <span class="op">=&lt;&lt;</span> Z.mkGe var <span class="op">=&lt;&lt;</span> Z.mkIntNum <span class="dv">0</span></span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p><strong>Step 3: Add joltage equality constraints</strong></p>
  <p>For each joltage equation we extracted earlier, we tell Z3: “the
  sum of these specific button presses must equal this joltage value.”
  This is the heart of our constraint system.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb77"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- for each equation</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>  forM_ (getLinearEquations light) <span class="op">$</span> \(joltage, buttons) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> buttonVars <span class="ot">=</span> <span class="fu">map</span> (vars <span class="op">!!</span>) buttons</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    buttonSum <span class="ot">&lt;-</span> Z.mkAdd buttonVars</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- the sum of the buttons must be equal to the joltage</span></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>    Z.optimizeAssert <span class="op">=&lt;&lt;</span> Z.mkEq buttonSum <span class="op">=&lt;&lt;</span> Z.mkIntNum joltage</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p><strong>Step 4: Define the optimization goal and solve</strong></p>
  <p>We create an expression representing the total button presses (sum
  of all variables), tell Z3 to minimize it, then run the solver. If a
  solution exists, we extract the value assigned to each variable and
  sum them up.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb78"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>  goal <span class="ot">&lt;-</span> Z.mkAdd vars</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>  Z.optimizeMinimize goal</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> Z.optimizeCheck []</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>  m <span class="ot">&lt;-</span> Z.optimizeGetModel</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-7"><a href="#cb78-7" aria-hidden="true" tabindex="-1"></a>  res <span class="ot">&lt;-</span> <span class="fu">sum</span> <span class="op">.</span> catMaybes <span class="op">&lt;$&gt;</span> <span class="fu">mapM</span> (Z.evalInt m) vars</span>
<span id="cb78-8"><a href="#cb78-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">fromInteger</span> res</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The verbosity is unfortunate (those nested <code>mkEq</code> and
  <code>mkIntNum</code> calls!), but the elegance of the approach shines
  through: we’ve transformed a complex search problem into a declarative
  specification that Z3 can solve optimally.</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> Wrapping it up</h3>
  <div class="row">
  <div class="lhs">
  <p>The final step is straightforward: run our Z3 script for each light
  and sum the results. We use <code>Z.evalZ3</code> to execute the Z3
  monad and get back our answer.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb79"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> [<span class="dt">Light</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>solvePart2 <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">mapM</span> (Z.evalZ3 <span class="op">.</span> script)</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> unsafePerformIO <span class="op">.</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p><strong>Note on <code>unsafePerformIO</code></strong>: Normally
  mixing IO into pure functions is dangerous, but here it’s safe because
  Z3 solving is referentially transparent—given the same input, it
  always produces the same output with no side effects we care about. We
  use <code>unsafePerformIO</code> purely to maintain a consistent API
  with Part 1.</p>
  <p>The beauty of this approach is its generality. Once you’ve modeled
  your problem as constraints and an objective function, Z3 handles all
  the complexity of finding an optimal solution. No manual search
  algorithms, no clever heuristics—just declarative problem
  specification and powerful automated reasoning. This is why SMT
  solvers are such a fundamental tool in modern software engineering and
  formal methods!</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h1 id="day-11">Day 11</h1>
  <h2 id="part-1-10">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Day 11 presents us with a network topology puzzle! We’re given a
  list of network devices and their connections, forming a directed
  acyclic graph (DAG). Each line describes which devices a particular
  node connects to.</p>
  <p>Here’s a simplified example of the input format:</p>
  <div class="sourceCode" id="cb80"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="an">a:</span><span class="co"> you</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="an">you:</span><span class="co"> c d</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="an">c:</span><span class="co"> out</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a><span class="an">d:</span><span class="co"> out</span></span></code></pre></div>
  <p>This describes a network where device <code>a</code> connects to
  <code>you</code>, device <code>you</code> has two outgoing connections
  to <code>c</code> and <code>d</code>, and both <code>c</code> and
  <code>d</code> connect to the final destination <code>out</code>.</p>
  <p>Our task for Part 1: <strong>count all possible paths</strong> from
  the starting node <code>"you"</code> to the destination node
  <code>"out"</code>. In the example above, there are 2 paths: -
  <code>you → c → out</code> - <code>you → d → out</code></p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb81"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiWayIf #-}</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TupleSections #-}</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ImportQualifiedPost #-}</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day11</span> <span class="kw">where</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">Text</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span> (readFile&#39;)</span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashMap.Strict</span> (<span class="dt">HashMap</span>)</span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashMap.Strict</span> <span class="kw">qualified</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span> (catMaybes, fromMaybe)</span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State.Strict</span> (<span class="dt">State</span>)</span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Debug.Trace</span> (traceShow, trace)</span>
<span id="cb81-15"><a href="#cb81-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Printf</span> (printf)</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>We’re using <code>Text</code> for efficient string handling (device
  IDs can be arbitrary strings), and <code>HashMap</code> for fast O(log
  n) lookups when traversing the graph—much better than linear searches
  through lists!</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> Modeling and parsing</h3>
  <div class="row">
  <div class="lhs">
  <p>The model is straightforward: we represent the entire network as a
  mapping from each device ID to its list of outgoing connections.</p>
  <p>Parsing is mercifully simple: each line has a device ID followed by
  a colon, then a space-separated list of devices it connects to. We
  strip the trailing colon with <code>Text.init</code> and collect the
  rest as a list of outgoing connections.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb82"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">DeviceId</span> <span class="ot">=</span> <span class="dt">Text</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Connections</span> <span class="ot">=</span> <span class="dt">HashMap</span> <span class="dt">DeviceId</span> [<span class="dt">DeviceId</span>]</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Connections</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> Map.fromList <span class="op">.</span> <span class="fu">map</span> parseConnections <span class="op">.</span> Text.lines <span class="op">.</span> Text.pack</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseConnections ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">DeviceId</span>, [<span class="dt">DeviceId</span>])</span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>  parseConnections line <span class="ot">=</span></span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (deviceId<span class="op">:</span>others) <span class="ot">=</span> Text.words line</span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> ((Text.init deviceId), others)</span></code></pre></div>
  </div>
  </div>
  <h3> Counting paths with dynamic programming</h3>
  <div class="row">
  <div class="lhs">
  <p>Here’s where things get interesting. The naive approach—recursively
  exploring every path from start to end—would repeatedly recompute the
  same subproblems. If device <code>c</code> is reachable from multiple
  places in the network, we’d count all paths from <code>c</code> to
  <code>out</code> multiple times!</p>
  <p><strong>Dynamic programming to the rescue!</strong> We’ll use
  memoization to cache the number of paths from each device to our
  destination. The first time we visit a device, we compute its path
  count and store it. Every subsequent visit just looks up the cached
  value.</p>
  <p>Think of it as working backwards from the destination: - The
  destination itself has exactly 1 path (the empty path) - Any device
  that connects directly to the destination has as many paths as it has
  outgoing edges to the destination - Any other device has paths equal
  to the sum of paths from all its children</p>
  <p>This is essentially a <strong>depth-first search with
  memoization</strong>, a classic DP technique for DAGs.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb83"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>The <code>countConnections</code> function implements our memoized
  DFS. Let’s break down what’s happening:</p>
  <p><strong>Initial cache setup</strong>: We start with a clever
  optimization—any device that connects directly to <code>end</code>
  already has at least one path. We pre-populate the cache by counting
  direct connections to the end node for every device.</p>
  <p><strong>The <code>buildMap</code> recursion</strong> handles three
  cases:</p>
  <ol type="1">
  <li><strong>Base case</strong>: If we’ve reached the end device,
  return a cache with just <code>{end: 1}</code></li>
  <li><strong>Cache hit</strong>: If we’ve already computed this
  device’s path count, return the existing cache unchanged</li>
  <li><strong>Cache miss</strong>: This is where the magic happens:
  <ul>
  <li>Get all children (devices this one connects to)</li>
  <li>Recursively build the cache for each child using
  <code>foldl'</code></li>
  <li>Sum up the path counts from all children (that’s the total paths
  through this device!)</li>
  <li>Insert this device’s count into the cache</li>
  </ul></li>
  </ol>
  <p>The fold accumulates the cache as we explore, ensuring each device
  is only computed once. When we’re done, we look up our starting device
  in the final cache to get the total path count.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb84"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="ot">countConnections ::</span> <span class="dt">Connections</span> <span class="ot">-&gt;</span> <span class="dt">DeviceId</span> <span class="ot">-&gt;</span> <span class="dt">DeviceId</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>countConnections grid start end <span class="ot">=</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> cache <span class="ot">=</span> Map.filter (<span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">.</span> <span class="fu">fmap</span> (<span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="op">==</span> end)) <span class="op">$</span> grid</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>      newCache <span class="ot">=</span> buildMap start cache</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>   <span class="kw">in</span> newCache <span class="op">Map.!</span> start</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    buildMap ::</span> <span class="dt">DeviceId</span> <span class="ot">-&gt;</span> <span class="dt">HashMap</span> <span class="dt">DeviceId</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">HashMap</span> <span class="dt">DeviceId</span> <span class="dt">Int</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>    buildMap device cache</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> device <span class="op">==</span> end <span class="ot">=</span> Map.singleton end <span class="dv">1</span></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> Map.member device cache <span class="ot">=</span> cache</span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> children <span class="ot">=</span> fromMaybe [] <span class="op">$</span> grid <span class="op">Map.!?</span> device</span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>            combine <span class="ot">=</span> <span class="fu">flip</span> buildMap</span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a>            childrensMap <span class="ot">=</span> foldl&#39; combine cache children</span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a>            childrenCount <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> catMaybes <span class="op">.</span> <span class="fu">map</span> (<span class="fu">flip</span> Map.lookup childrensMap) <span class="op">$</span> children</span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a>         <span class="kw">in</span> Map.insert device childrenCount <span class="op">$</span> childrensMap</span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> <span class="dt">Connections</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb84-19"><a href="#cb84-19" aria-hidden="true" tabindex="-1"></a>solvePart1 graph <span class="ot">=</span> countConnections graph <span class="st">&quot;you&quot;</span> <span class="st">&quot;out&quot;</span></span>
<span id="cb84-20"><a href="#cb84-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-21"><a href="#cb84-21" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb84-22"><a href="#cb84-22" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <h2 id="part-2-10">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>Part 2 cranks up the complexity: now we need to count only paths
  from <code>"svr"</code> to <code>"out"</code> that pass through
  <strong>both</strong> <code>"fft"</code> and <code>"dac"</code>
  devices. Not just one or the other—both!</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> The inclusion-exclusion principle</h3>
  <div class="row">
  <div class="lhs">
  <p>At first glance, this seems like we need a completely different
  algorithm. But there’s an elegant mathematical trick we can use: the
  <a
  href="https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle">inclusion-exclusion
  principle</a>.</p>
  <p>Think about it in terms of set operations. We want paths that
  include both checkpoints, which is equivalent to:</p>
  <pre><code>allPaths - pathsWithoutDac - pathsWithoutFft + pathsWithoutEither</code></pre>
  <p>Why does this work? - Start with <strong>all paths</strong> from
  svr to out - Subtract paths that <strong>don’t go through dac</strong>
  (removes all paths missing that checkpoint) - Subtract paths that
  <strong>don’t go through fft</strong> (removes all paths missing that
  checkpoint) - Add back paths that <strong>avoid both</strong> (we
  subtracted these twice, so we need to add them once)</p>
  <p>This is the classic inclusion-exclusion formula: |A ∩ B| = |U| -
  |Ā| - |B̄| + |Ā ∩ B̄|</p>
  <p>And the beautiful part? We can compute “paths that avoid X” by
  simply removing X from the graph and counting paths normally!</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb86"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2 ::</span> <span class="dt">Connections</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>solvePart2 graph <span class="ot">=</span> <span class="fu">all</span> <span class="op">-</span> noDac <span class="op">-</span> noFft <span class="op">+</span> noDacNoFft</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">all</span>   <span class="ot">=</span> countConnections graph <span class="st">&quot;svr&quot;</span> <span class="st">&quot;out&quot;</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    noDac <span class="ot">=</span> countConnections (Map.delete <span class="st">&quot;dac&quot;</span> graph) <span class="st">&quot;svr&quot;</span> <span class="st">&quot;out&quot;</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    noFft <span class="ot">=</span> countConnections (Map.delete <span class="st">&quot;fft&quot;</span> graph) <span class="st">&quot;svr&quot;</span> <span class="st">&quot;out&quot;</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>    noDacNoFft <span class="ot">=</span> countConnections (Map.delete <span class="st">&quot;dac&quot;</span> <span class="op">$</span> Map.delete <span class="st">&quot;fft&quot;</span> <span class="op">$</span> graph) <span class="st">&quot;svr&quot;</span> <span class="st">&quot;out&quot;</span></span></code></pre></div>
  </div>
  </div>
  <h3> Alternative approach: counting subpaths</h3>
  <div class="row">
  <div class="lhs">
  <p>There’s another way to think about this problem that’s perhaps more
  intuitive. Any path that goes through both dac and fft must visit them
  in some order:</p>
  <ul>
  <li>Either: <code>svr → ... → dac → ... → fft → ... → out</code></li>
  <li>Or: <code>svr → ... → fft → ... → dac → ... → out</code></li>
  </ul>
  <p>These are mutually exclusive cases (you can’t visit dac before fft
  <em>and</em> fft before dac in the same path), so we can count them
  separately and add the results.</p>
  <p>For the first case, we need:</p>
  <pre><code>(paths from svr to dac) × (paths from dac to fft) × (paths from fft to out)</code></pre>
  <p>Why multiplication? Because each path in the first segment can be
  paired with each path in the second segment, and each of those
  combinations can be paired with each path in the third segment. That’s
  the fundamental counting principle!</p>
  <p>Similarly for the second case. Add them together:</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb88"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart2&#39; ::</span> <span class="dt">Connections</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>solvePart2&#39; graph <span class="ot">=</span> paths <span class="st">&quot;svr&quot;</span> <span class="st">&quot;dac&quot;</span> <span class="op">*</span> paths <span class="st">&quot;dac&quot;</span> <span class="st">&quot;fft&quot;</span> <span class="op">*</span> paths <span class="st">&quot;fft&quot;</span> <span class="st">&quot;out&quot;</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>                  <span class="op">+</span> paths <span class="st">&quot;svr&quot;</span> <span class="st">&quot;fft&quot;</span> <span class="op">*</span> paths <span class="st">&quot;fft&quot;</span> <span class="st">&quot;dac&quot;</span> <span class="op">*</span> paths <span class="st">&quot;dac&quot;</span> <span class="st">&quot;out&quot;</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>    paths <span class="ot">=</span> countConnections graph</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a><span class="ot">part2 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>part2 <span class="ot">=</span> solvePart2 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>This alternative formulation is arguably clearer—it directly
  expresses the structure of the paths we’re counting. Both solutions
  produce the same answer, but I find the inclusion-exclusion approach
  (<code>solvePart2</code>) more elegant and generalizable. If we needed
  to check for three or four required checkpoints, the combinatorial
  explosion of cases in the subpath approach would get messy fast, while
  inclusion-exclusion scales gracefully.</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h1 id="day-12">Day 12</h1>
  <h2 id="part-1-11">Part 1</h2>
  <div class="row">
  <div class="lhs">
  <p>Day 12 brings us a festive packing puzzle! We’re playing Santa’s
  logistics coordinator, trying to figure out which Christmas trees have
  enough space underneath to hold all their designated presents.</p>
  <p>The input gives us two things: a catalog of present shapes and a
  list of trees with their packing requirements.</p>
  <p>Each present is defined by its shape on a 2D grid:</p>
  <div class="sourceCode" id="cb89"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="an">0:</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a> ###</span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a> ##.</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a> ##.</span></code></pre></div>
  <p>The first line shows the present’s index (<code>0</code> in this
  case). The following rows describe the shape, where <code>#</code>
  represents solid present and <code>.</code> represents empty space.
  This present occupies 5 cells.</p>
  <p>Trees are specified with their dimensions and the presents they
  need to hold:</p>
  <div class="sourceCode" id="cb90"><pre
  class="sourceCode md"><code class="sourceCode markdown"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="an">4x4:</span><span class="co"> 0 0 0 0 2 0</span></span></code></pre></div>
  <p>This tree has a 4×4 grid of space underneath (16 cells total), and
  needs to accommodate: four copies of present <code>0</code>, one copy
  of present <code>2</code>, and one copy of present <code>0</code>
  again.</p>
  <p><strong>Our task</strong>: Determine which trees have sufficient
  area to fit all their assigned presents.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb91"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Day12</span> <span class="kw">where</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (unsnoc)</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Bifunctor</span> (bimap)</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.Split</span> (splitOn)</span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span> (fromMaybe)</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> ((&gt;&gt;&gt;))</span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span> (readFile&#39;)</span></code></pre></div>
  </div>
  </div>
  <h3> Modeling the problem</h3>
  <div class="row">
  <div class="lhs">
  <p>The model is straightforward: we represent each present as a 2D
  grid of booleans, where <code>True</code> indicates a solid cell.
  Trees track their dimensions and the list of present indices they need
  to hold.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb92"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Present</span> <span class="ot">=</span> [[<span class="dt">Bool</span>]]</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> <span class="ot">=</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Tree</span> {<span class="ot"> _width ::</span> <span class="dt">Int</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>       ,<span class="ot"> _height ::</span> <span class="dt">Int</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>       ,<span class="ot"> _presents ::</span> [<span class="dt">Int</span>]</span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a>       } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Problem</span> <span class="ot">=</span> ([<span class="dt">Present</span>], [<span class="dt">Tree</span>])</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>Parsing follows the input structure: we split on double newlines to
  separate the present catalog from the tree list. Each present’s shape
  is converted to a grid of booleans by testing for <code>'#'</code>
  characters. Tree parsing extracts dimensions from the
  <code>WxH:</code> prefix and reads the space-separated present
  indices.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb93"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Problem</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>parse <span class="ot">=</span> splitOn <span class="st">&quot;\n\n&quot;</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>        <span class="op">&gt;&gt;&gt;</span> unsnoc</span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">&gt;&gt;&gt;</span> fromMaybe <span class="fu">undefined</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">&gt;&gt;&gt;</span> bimap (<span class="fu">map</span> parsePresent)</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>                  (<span class="fu">map</span> parseTree <span class="op">.</span> <span class="fu">lines</span>)</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  parsePresent ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Present</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>  parsePresent <span class="ot">=</span> <span class="fu">lines</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">tail</span> <span class="op">&gt;&gt;&gt;</span> <span class="fu">map</span> (<span class="fu">map</span> (<span class="op">==</span> <span class="ch">&#39;#&#39;</span>))</span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  parseTree ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span></span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>  parseTree str <span class="ot">=</span> <span class="kw">let</span> (<span class="fu">fst</span><span class="op">:</span>presents) <span class="ot">=</span> splitOn <span class="st">&quot; &quot;</span> str</span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>                      (width, height) <span class="ot">=</span> <span class="fu">break</span> (<span class="op">==</span> <span class="ch">&#39;x&#39;</span>) (<span class="fu">init</span> <span class="fu">fst</span>)</span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">in</span> <span class="dt">Tree</span> (<span class="fu">read</span> width) (<span class="fu">read</span> (<span class="fu">drop</span> <span class="dv">1</span> height)) (<span class="fu">map</span> <span class="fu">read</span> presents)</span></code></pre></div>
  </div>
  </div>
  <h3> The real problem: 2D bin packing</h3>
  <div class="row">
  <div class="lhs">
  <p>At first glance, this might look like the classic <a
  href="https://en.wikipedia.org/wiki/Knapsack_problem">knapsack
  problem</a>—we need to fit items into a container. But it’s actually
  harder! This is a <strong>2D bin packing problem</strong>, where we
  need to arrange irregularly-shaped presents within a rectangular
  space.</p>
  <p>The general version of this problem is NP-complete. A proper
  solution would need to:</p>
  <ol type="1">
  <li>Try different rotations of each present (if rotation is
  allowed)</li>
  <li>Consider all possible positions for placing each present</li>
  <li>Ensure presents don’t overlap with each other</li>
  <li>Backtrack when a configuration doesn’t work</li>
  </ol>
  <p>This could involve sophisticated algorithms like genetic
  algorithms, simulated annealing, or branch-and-bound search. For large
  inputs, even approximate solutions are challenging!</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h3> A pragmatic shortcut</h3>
  <div class="row">
  <div class="lhs">
  <p>Here’s where things get interesting. After examining the actual
  puzzle input, I noticed something: <strong>for every tree in the
  input, a simple area check is sufficient</strong>. That is, if the sum
  of all present areas is less than or equal to the tree’s total area,
  then those presents will actually fit when properly arranged.</p>
  <p>This suggests the puzzle author deliberately crafted the input to
  avoid the NP-complete complexity. Perhaps the presents are designed to
  pack efficiently, or the tree spaces are generous enough that optimal
  packing isn’t required. Either way, we can solve Part 1 with a
  straightforward area comparison!</p>
  <p>The solution filters trees by checking if their total area can
  accommodate all assigned presents. We pre-compute each present’s area
  (counting <code>True</code> cells in its grid), then for each tree,
  sum up the areas of its required presents and compare against the
  tree’s dimensions.</p>
  </div>
  <div class="code">
  <div class="sourceCode" id="cb94"><pre
  class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solvePart1 ::</span> <span class="dt">Problem</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>solvePart1 (presents, trees) <span class="ot">=</span> <span class="fu">length</span> <span class="op">$</span> <span class="fu">filter</span> (fitsAllPresents) trees</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  fitsAllPresents ::</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a>  fitsAllPresents (<span class="dt">Tree</span> width height presents&#39;) <span class="ot">=</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> totalPresentsArea <span class="ot">=</span> foldl&#39; (\acc (ix, count) <span class="ot">-&gt;</span> acc <span class="op">+</span> (count <span class="op">*</span> (presentsArea <span class="op">!!</span> ix))) <span class="dv">0</span> (<span class="fu">zip</span> [<span class="dv">0</span><span class="op">..</span>] presents&#39;)</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>        totalArea <span class="ot">=</span> width <span class="op">*</span> height</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> totalPresentsArea <span class="op">&lt;=</span> (totalArea)</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a>  presentsArea <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">length</span> <span class="op">.</span> <span class="fu">filter</span> <span class="fu">id</span> <span class="op">.</span> <span class="fu">concat</span>) presents</span>
<span id="cb94-11"><a href="#cb94-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-12"><a href="#cb94-12" aria-hidden="true" tabindex="-1"></a><span class="ot">part1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb94-13"><a href="#cb94-13" aria-hidden="true" tabindex="-1"></a>part1 <span class="ot">=</span> solvePart1 <span class="op">.</span> parse</span></code></pre></div>
  </div>
  </div>
  <div class="row">
  <div class="lhs">
  <p>This elegant simplification turns an intractable problem into an
  O(n) solution. Sometimes the best algorithm is recognizing when you
  don’t need one!</p>
  </div>
  <div class="code">

  </div>
  </div>
  <h2 id="part-2-11">Part 2</h2>
  <div class="row">
  <div class="lhs">
  <p>There is no Part 2, part 2 is the stars we collected along the way
  (:</p>
  <p>I hope this has been useful to you, if it was please consider
  leaving a star in the repo.</p>
  <hr />
  <p>Merry Christmas, <br> Hugo Vilela <br></p>
  </div>
  <div class="code">

  </div>
  </div>

    <script>
    // TOC Theme Toggle
    (function () {
      const toc = document.getElementById('TOC');
      const toggle = document.getElementById('theme-toggle');
      const icon = document.querySelector('.theme-icon');

      if (!toc || !toggle || !icon) return;

      // Load saved theme preference
      const savedTheme = localStorage.getItem('tocTheme') || 'light';
      if (savedTheme === 'dark') {
        toc.classList.add('dark-theme');
        icon.textContent = '🌙';
      }

      // Toggle theme on click
      toggle.addEventListener('click', function () {
        toc.classList.toggle('dark-theme');
        const isDark = toc.classList.contains('dark-theme');
        icon.textContent = isDark ? '🌙' : '☀️';
        localStorage.setItem('tocTheme', isDark ? 'dark' : 'light');
      });
    })();
  </script>
</body>

</html>
